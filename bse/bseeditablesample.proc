/* BSE - Bedevilled Sound Engine	-*-mode: c;-*-
 * Copyright (C) 2002 Tim Janik
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */
#include        <bse/bseplugin.h>
#include        <bse/bseprocedure.h>
#include        <bse/bseeditablesample.h>
#include        <bse/gsldatahandle.h>


AUTHOR	= "Tim Janik <timj@gtk.org>";
CRIGHTS	= "Tim Janik";
DATE	= "2002";


METHOD (BseEditableSample, get-length) {
  HELP	= ("Return the number of values in the sample.");
  IN	= g_param_spec_object ("esample", "Editable Sample", NULL,
			       BSE_TYPE_EDITABLE_SAMPLE, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_uint ("length", NULL, "Number of values",
			     0, G_MAXINT, 1, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseEditableSample *esample = g_value_get_object (in_values++);
  GslDataCache *dcache = esample->wchunk ? esample->wchunk->dcache : NULL;
  
  /* check parameters */
  if (!BSE_IS_EDITABLE_SAMPLE (esample))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  g_value_set_uint (out_values++, dcache ? dcache->dhandle->n_values : 0);

  return BSE_ERROR_NONE;
}

METHOD (BseEditableSample, get-n-channels) {
  HELP	= ("Return the number of channels in the sample.");
  IN	= g_param_spec_object ("esample", "Editable Sample", NULL,
			       BSE_TYPE_EDITABLE_SAMPLE, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_uint ("n-channels", NULL, "Number of channels",
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseEditableSample *esample = g_value_get_object (in_values++);

  /* check parameters */
  if (!BSE_IS_EDITABLE_SAMPLE (esample))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  g_value_set_uint (out_values++, esample->wchunk ? esample->wchunk->n_channels : 1);

  return BSE_ERROR_NONE;
}

METHOD (BseEditableSample, get-osc-freq) {
  HELP	= ("Return the oscillator frequency for the sample.");
  IN	= g_param_spec_object ("esample", "Editable Sample", NULL,
			       BSE_TYPE_EDITABLE_SAMPLE, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_float ("osc-freq", NULL, "Oscillator Frequency",
			      BSE_MIN_OSC_FREQ_d, BSE_MAX_OSC_FREQ_d,
			      BSE_KAMMER_FREQ,
			      BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseEditableSample *esample = g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_EDITABLE_SAMPLE (esample))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  g_value_set_float (out_values++, esample->wchunk ? esample->wchunk->osc_freq : BSE_KAMMER_FREQ);

  return BSE_ERROR_NONE;
}

METHOD (BseEditableSample, read-samples) {
  HELP	= ("Read a set of samples from a specific offset.");
  IN	= g_param_spec_object ("esample", "Editable Sample", NULL,
			       BSE_TYPE_EDITABLE_SAMPLE, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_uint ("voffset", NULL, "Value offset",
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_boxed ("sample_block", NULL, "Block of samples",
			      BSW_TYPE_VALUE_BLOCK, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseEditableSample *esample = g_value_get_object (in_values++);
  guint              voffset = g_value_get_uint (in_values++);
  GslDataCache *dcache = esample->wchunk ? esample->wchunk->dcache : NULL;
  BswValueBlock *vblock;

  /* check parameters */
  if (!BSE_IS_EDITABLE_SAMPLE (esample))
    return BSE_ERROR_PROC_PARAM_INVAL;

  if (!dcache || voffset >= dcache->dhandle->n_values)
    vblock = bsw_value_block_new (1024);
  else
    {
      GslDataCacheNode *dnode = gsl_data_cache_ref_node (dcache, voffset, TRUE);
      guint i, l, dnode_length = dcache->node_size;

      l = dnode_length - (voffset - dnode->offset) + dcache->padding;
      l = MIN (l, dcache->dhandle->n_values - voffset);
      vblock = bsw_value_block_new (l);
      for (i = 0; i < l; i++)
	vblock->values[i] = dnode->data[voffset - dnode->offset + i];
      gsl_data_cache_unref_node (dcache, dnode);
    }

  /* set output parameters */
  g_value_set_boxed_take_ownership (out_values++, vblock);

  return BSE_ERROR_NONE;
}

METHOD (BseEditableSample, collect-stats) {
  HELP	= ("Collect statistics from sample blocks as (minimum, maximum) pairs.");
  IN	= g_param_spec_object ("esample", "Editable Sample", NULL,
			       BSE_TYPE_EDITABLE_SAMPLE, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_uint ("voffset", NULL, "Offset of first stat block",
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_double ("offset_scale", NULL, "Factor to scale voffset increments with",
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_uint ("block_size", NULL, "Block size to compute stat pairs from",
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_uint ("stepping", NULL, "Stepping within a stat block",
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_uint ("max_pairs", NULL, "Maximum number of (min, max) pairs to collect",
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_boxed ("sample_block", NULL, "Block of samples",
			      BSW_TYPE_VALUE_BLOCK, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseEditableSample *esample    = g_value_get_object (in_values++);
  guint              voffset    = g_value_get_uint (in_values++);
  double             offs_scale = g_value_get_double (in_values++);
  guint              block_size = g_value_get_uint (in_values++);
  guint              stepping   = g_value_get_uint (in_values++);
  guint              max_pairs  = g_value_get_uint (in_values++);
  BswValueBlock *vblock;
  GslDataCache *dcache = esample->wchunk ? esample->wchunk->dcache : NULL;

  /* check parameters */
  if (!BSE_IS_EDITABLE_SAMPLE (esample) || stepping < 1)
    return BSE_ERROR_PROC_PARAM_INVAL;

  if (!esample->wchunk || voffset + block_size > dcache->dhandle->n_values)
    vblock = bsw_value_block_new (max_pairs * 2);
  else
    {
      GslDataCacheNode *dnode = gsl_data_cache_ref_node (dcache, voffset, GSL_DATA_CACHE_DEMAND_LOAD);
      guint j, dnode_length = dcache->node_size;

      vblock = bsw_value_block_new (max_pairs * 2);
      for (j = 0; j < max_pairs; j++)
	{
	  guint i, cur_offset = j * offs_scale;
	  gfloat min = +1, max = -1;

	  /* keep alignment across offset scaling */
	  cur_offset /= stepping;
	  cur_offset = voffset + cur_offset * stepping;

	  /* collect stats for one block */
	  for (i = cur_offset; i < cur_offset + block_size; i += stepping)
	    {
	      guint pos;
	      
	      if (i < dnode->offset || i >= dnode->offset + dnode_length)
		{
		  gsl_data_cache_unref_node (dcache, dnode);
		  /* demand_load the first block only */
		  dnode = gsl_data_cache_ref_node (dcache, i, j == 0 ? GSL_DATA_CACHE_DEMAND_LOAD : GSL_DATA_CACHE_PEEK);
		  if (!dnode)
		    goto break_loops;
		}
	      pos = i - dnode->offset;
	      min = MIN (min, dnode->data[pos]);
	      max = MAX (max, dnode->data[pos]);
	    }
	  vblock->values[j * 2] = min;
	  vblock->values[j * 2 + 1] = max;
	}
      gsl_data_cache_unref_node (dcache, dnode);
    break_loops:
      vblock->n_values = j * 2;
    }

  /* set output parameters */
  g_value_set_boxed_take_ownership (out_values++, vblock);

  return BSE_ERROR_NONE;
}
