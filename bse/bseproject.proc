// Licensed GNU LGPL v2.1 or later: http://www.gnu.org/licenses/lgpl.html
#include <bse/bseplugin.hh>
#include <bse/bseprocedure.hh>
#include <bse/bseproject.hh>
#include <bse/bsestorage.hh>
#include <bse/bsesong.hh>
#include <bse/bseundostack.hh>
#include <bse/bsewaverepo.hh>
#include <bse/bsecsynth.hh>
#include <bse/bsemidisynth.hh>
#include <bse/bsemidifile.hh>
#include <bse/bsemidireceiver.hh>
#include <bse/bsemidinotifier.hh>
#include <bse/bseengine.hh>
#include "bsecxxplugin.hh"
#include "bsebuiltin_externs.cc"


AUTHORS = "Tim Janik <timj@gtk.org>";
LICENSE = "GNU Lesser General Public License";



METHOD (BseProject, get-midi-notifier) {
  HELP  = "Retrieve the project's midi notifier object.";
  IN    = bse_param_spec_object ("project", "Project", NULL, BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_object ("midi_notifier", NULL, NULL, BSE_TYPE_MIDI_NOTIFIER, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseProject *self = (BseProject*) bse_value_get_object (in_values++);

  /* check parameters */
  if (!BSE_IS_PROJECT (self))
    return Bse::ERROR_PROC_PARAM_INVAL;

  BseMidiNotifier *notifier = bse_project_get_midi_notifier (self);

  /* set output parameters */
  bse_value_set_object (out_values++, G_OBJECT (notifier));

  return Bse::ERROR_NONE;
}



METHOD (BseProject, store-bse, "File/Store") {
  HELP  = "Save supers of a project into a BSE file. "
          "If no super is specified, the project itself is stored.";
  IN    = bse_param_spec_object ("project", "Project", NULL,
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  IN    = bse_param_spec_object ("super", "Super", NULL,
                                 BSE_TYPE_SUPER, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("file-name", "File", "Destination file name",
                            NULL, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_bool ("self-contained", "Self Contained",
                          "Whether references to other objects (e.g. samples) should "
                          "be stored or whether to include everything in a self-contained .bse file",
                          FALSE, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_genum ("error", "Error", "Error indicating possible failures",
                                BSE_TYPE_ERROR_TYPE, Bse::ERROR_NONE,
                                SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseProject *project = (BseProject*) bse_value_get_object (in_values++);
  BseSuper *super = (BseSuper*) bse_value_get_object (in_values++);
  const char *file_name = sfi_value_get_string (in_values++);
  gboolean self_contained = sfi_value_get_bool (in_values++);
  Bse::ErrorType error;

  /* check parameters */
  if (!BSE_IS_PROJECT (project) || !file_name)
    return Bse::ERROR_PROC_PARAM_INVAL;
  if (super && BSE_ITEM (super)->parent != BSE_ITEM (project))
    return Bse::ERROR_PROC_PARAM_INVAL;

  error = bse_project_store_bse (project, super, file_name, self_contained);

  /* set output parameters */
  g_value_set_enum (out_values++, error);

  return Bse::ERROR_NONE;
}

METHOD (BseProject, create-song) {
  HELP  = "Create a song for this project.";
  IN    = bse_param_spec_object ("project", "Project", "The project",
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("name", "Name", "Song name",
                            NULL, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_object ("song", "Song", "The new song",
                                 BSE_TYPE_SONG, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseContainer *container = (BseContainer*) bse_value_get_object (in_values++);
  const char *name = sfi_value_get_string (in_values++);
  BseUndoStack *ustack;
  BseItem *child;

  /* check parameters */
  if (!BSE_IS_PROJECT (container))
    return Bse::ERROR_PROC_PARAM_INVAL;

  /* action */
  ustack = bse_item_undo_open (container, "create-song");
  child = (BseItem*) bse_container_new_child (container, BSE_TYPE_SONG, NULL);
  if (name)
    bse_item_set (child, "uname", name, NULL);
  bse_item_push_undo_proc (container, "remove-snet", child);
  bse_item_undo_close (ustack);

  /* set output parameters */
  bse_value_set_object (out_values++, child);

  return Bse::ERROR_NONE;
}

METHOD (BseProject, get-wave-repo) {
  HELP  = "Ensure the project has a wave repository";
  IN    = bse_param_spec_object ("project", "Project", "The project",
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_object ("wrepo", "Wave Repo", "The project's unique wave repo",
                                 BSE_TYPE_WAVE_REPO, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseProject *project = (BseProject*) bse_value_get_object (in_values++);
  BseWaveRepo *wrepo = NULL;

  /* check parameters */
  if (!BSE_IS_PROJECT (project))
    return Bse::ERROR_PROC_PARAM_INVAL;

  /* action */
  wrepo = bse_project_get_wave_repo (project);

  /* set output parameters */
  bse_value_set_object (out_values++, wrepo);

  return Bse::ERROR_NONE;
}

METHOD (BseProject, create-csynth) {
  HELP  = "Create a synthsizer network for this project.";
  IN    = bse_param_spec_object ("project", "Project", "The project",
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("name", "Name", "Synth network name",
                            NULL, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_object ("csynth", "Synthesizer Network", "New synth network",
                                 BSE_TYPE_CSYNTH, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseContainer *container = (BseContainer*) bse_value_get_object (in_values++);
  const char *name = sfi_value_get_string (in_values++);
  BseUndoStack *ustack;
  BseItem *child;

  /* check parameters */
  if (!BSE_IS_PROJECT (container))
    return Bse::ERROR_PROC_PARAM_INVAL;

  /* action */
  ustack = bse_item_undo_open (container, "create-csynth");
  child = (BseItem*) bse_container_new_child (container, BSE_TYPE_CSYNTH, NULL);
  if (name)
    bse_item_set (child, "uname", name, NULL);
  bse_item_push_undo_proc (container, "remove-snet", child);
  bse_item_undo_close (ustack);

  /* set output parameters */
  bse_value_set_object (out_values++, child);

  return Bse::ERROR_NONE;
}

METHOD (BseProject, create-midi-synth) {
  HELP  = "Create a MIDI synthesizer network for this project.";
  IN    = bse_param_spec_object ("project", "Project", "The project",
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("name", "Name", "MIDI synth name",
                            NULL, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_object ("midi_synth", "MIDI Synthesizer", "New MIDI synth",
                                 BSE_TYPE_MIDI_SYNTH, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseContainer *container = (BseContainer*) bse_value_get_object (in_values++);
  const char *name = sfi_value_get_string (in_values++);
  BseUndoStack *ustack;
  BseItem *child;

  /* check parameters */
  if (!BSE_IS_PROJECT (container))
    return Bse::ERROR_PROC_PARAM_INVAL;

  /* action */
  ustack = bse_item_undo_open (container, "create-midi-synth");
  child = (BseItem*) bse_container_new_child (container, BSE_TYPE_MIDI_SYNTH, NULL);
  if (name)
    bse_item_set (child, "uname", name, NULL);
  bse_item_push_undo_proc (container, "remove-snet", child);
  bse_item_undo_close (ustack);

  /* set output parameters */
  bse_value_set_object (out_values++, child);

  return Bse::ERROR_NONE;
}

METHOD (BseProject, remove-snet) {
  HELP  = "Remove an existing synthesizer network from this project.";
  IN    = bse_param_spec_object ("project", "Project", "The project",
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  IN    = bse_param_spec_object ("snet", "SNet", "Synthesizer Network",
                                 BSE_TYPE_SNET, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseContainer *self = (BseContainer*) bse_value_get_object (in_values++);
  BseItem *child = (BseItem*) bse_value_get_object (in_values++);
  BseUndoStack *ustack;

  /* check parameters */
  if (!BSE_IS_PROJECT (self) || !BSE_IS_SNET (child) || child->parent != (BseItem*) self)
    return Bse::ERROR_PROC_PARAM_INVAL;

  /* action */
  if (!BSE_SOURCE_PREPARED (self))
    {
      ustack = bse_item_undo_open (self, "remove-child %s", bse_object_debug_name (child));
      /* remove object references */
      bse_container_uncross_undoable (BSE_CONTAINER (self), child);
      /* how to get rid of the item once backed up */
      bse_item_push_redo_proc (self, "remove-snet", child);
      /* remove (without redo queueing) */
      bse_container_remove_backedup (BSE_CONTAINER (self), child, ustack);
      /* done */
      bse_item_undo_close (ustack);
    }

  return Bse::ERROR_NONE;
}

METHOD (BseProject, get-supers) {
  HELP  = "Retrieve all supers of this project.";
  IN    = bse_param_spec_object ("project", NULL, NULL,
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_boxed ("super_list", NULL, NULL, BSE_TYPE_IT3M_SEQ, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseProject *project = (BseProject*) bse_value_get_object (in_values++);
  BseIt3mSeq *iseq;
  GSList *slist;

  /* check parameters */
  if (!BSE_IS_PROJECT (project))
    return Bse::ERROR_PROC_PARAM_INVAL;

  /* action */
  iseq = bse_it3m_seq_new ();
  for (slist = project->supers; slist; slist = slist->next)
    bse_it3m_seq_append (iseq, (BseItem*) slist->data);

  /* set output parameters */
  bse_value_take_boxed (out_values++, iseq);

  return Bse::ERROR_NONE;
}


METHOD (BseProject, get-state) {
  HELP  = "Retrieve the current project state.";
  IN    = bse_param_spec_object ("project", "Project", "The project",
                                 BSE_TYPE_PROJECT, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_genum ("state", "State", "Project playback/activation state",
                                BSE_TYPE_PROJECT_STATE, BSE_PROJECT_INACTIVE, SFI_PARAM_STANDARD);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  BseProject *self = (BseProject*) bse_value_get_object (in_values++);

  /* check parameters */
  if (!BSE_IS_PROJECT (self))
    return Bse::ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  g_value_set_enum (out_values++, self->state);

  return Bse::ERROR_NONE;
}
