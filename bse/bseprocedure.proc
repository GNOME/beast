/* BSE - Bedevilled Sound Engine        -*-mode: c;-*-
 * Copyright (C) 2002 Tim Janik
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */
#include <bse/bseplugin.h>
#include <bse/bseprocedure.h>
#include <bse/bsescripthelper.h>
#include <bse/bseserver.h>
#include <bse/gslcommon.h>      /* gsl_get_config */
#include <bse/gslmath.h>        /* gsl_temp_freq */
#include <string.h>     /* strchr */
#include <stdlib.h>     /* strtol */


AUTHORS = "Tim Janik <timj@gtk.org>";
LICENSE = "GNU General Public License";

PROCEDURE (bse-note-to-freq, "Note to Freq") {
  HELP  = "Retrieve the frequency of a certain note.";
  IN    = bse_pspec_note_simple ("note", "Note", NULL, SFI_PARAM_DEFAULT);
  IN    = bse_param_spec_fine_tune ("fine_tune", "Fine Tune", NULL);
  OUT   = sfi_pspec_real ("frequency", "Frequency", NULL,
			  BSE_KAMMER_FREQUENCY_f, 0, BSE_MAX_FREQUENCY_f, 0.1,
			  SFI_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  gint       note       = sfi_value_get_int (in_values++);
  gint       fine_tune  = sfi_value_get_int (in_values++);
  BseNoteDescription *info;
  gfloat freq;
  
  /* action */
  info = bse_note_description (note, fine_tune);
  if (!info->name)
    freq = 0;
  else
    freq = info->freq;
  bse_note_description_free (info);
  
  /* set out params */
  sfi_value_set_real (out_values++, freq);
  
  return BSE_ERROR_NONE;
}

PROCEDURE (bse-note-from-freq, "Note from Freq") {
  HELP  = "Retrieve the note of a certain frequency.";
  IN    = sfi_pspec_real ("frequency", "Frequency", NULL,
			  BSE_KAMMER_FREQUENCY_f, 0, BSE_MAX_FREQUENCY_f, 0.1,
			  SFI_PARAM_DEFAULT);
  OUT   = sfi_pspec_note ("note", "Note", NULL, SFI_KAMMER_NOTE, SFI_MIN_NOTE, SFI_MAX_NOTE, TRUE, SFI_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  gfloat frequency = sfi_value_get_real (in_values++);
  
  /* set out params */
  sfi_value_set_int (out_values++, bse_note_from_freq (frequency));
  
  return BSE_ERROR_NONE;
}

PROCEDURE (bse-type-blurb, "Type Blurb") {
  HELP  = "Retrieve the blurb for a specific type.";
  IN    = sfi_pspec_string ("type", NULL, NULL, NULL, SFI_PARAM_DEFAULT);
  OUT   = sfi_pspec_string ("blurb", NULL, NULL, NULL, SFI_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  gchar *stype = sfi_value_get_string (in_values++);
  GType type;

  /* check parameters */
  if (!stype)
    return BSE_ERROR_PROC_PARAM_INVAL;

  type = g_type_from_name (stype);

  /* set out params */
  sfi_value_set_string (out_values++, type ? bse_type_blurb (type) : NULL);

  return BSE_ERROR_NONE;
}

static gdouble
str2num (const gchar *str,
         guint        nth)
{
  gchar *num_any = ".0123456789", *num_first = num_any + 1;
  while (nth--)
    {
      /* skip number */
      if (*str && strchr (num_first, *str))
        do
          str++;
        while (*str && strchr (num_any, *str));
      /* and trailing non-number stuff */
      while (*str && !strchr (num_first, *str))
        str++;
      if (!*str)
        return 0;       /* no number */
    }
  if (strchr (num_first, *str))
    return g_strtod (str, NULL);
  return 0; /* no number */
}

PROCEDURE (bse-string-extract-number, "String Extract Number") {
  HELP  = "Retrieve numbers from a string.";
  IN    = sfi_pspec_string ("string", NULL, NULL, NULL, SFI_PARAM_DEFAULT);
  IN    = sfi_pspec_string ("format", NULL, NULL, NULL, SFI_PARAM_DEFAULT);
  IN    = sfi_pspec_real ("aux_base", NULL, NULL, 0, -SFI_MAXNUM, SFI_MAXNUM, 0, SFI_PARAM_DEFAULT);
  IN    = sfi_pspec_real ("dflt", NULL, NULL, 0, -SFI_MAXNUM, SFI_MAXNUM, 0, SFI_PARAM_DEFAULT);
  OUT   = sfi_pspec_real ("number", NULL, NULL, 0, -SFI_MAXNUM, SFI_MAXNUM, 0, SFI_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
        const GValue      *in_values,
        GValue            *out_values)
{
  /* extract parameter values */
  gchar *string   = sfi_value_get_string (in_values++);
  gchar *format   = sfi_value_get_string (in_values++);
  SfiReal aux_base = sfi_value_get_real (in_values++);
  SfiReal dflt     = sfi_value_get_real (in_values++);
  SfiReal number = dflt;

  if (string)
    {
      if (format)
        {
          gchar *base, *ep = NULL;
          switch (*format)
            {
              glong l;
            case '#':
              number = str2num (++format, 0);
              break;
            case 'n':
              l = strtol (++format, &ep, 10);
              number = str2num (string, l);
              break;
            case 'b':
              l = strtol (++format, &ep, 10);
              base = g_path_get_basename (string);
              number = str2num  (base ? base : string, l);
              g_free (base);
              break;
            case 'c':
              format++;
              number = aux_base;
              if (*format == '*')
                {
                  gdouble factor = g_strtod (++format, &ep);
                  number *= factor;
                }
              else
                ep = (char*) format;
              break;
            default:
              /* ("Invalid chunk format given: modifier `%c'", *format) */
              number = 0;
              break;
            }
          if (ep && *ep)
            {
              if (*ep == 'm')       /* interpret d as midi note and return freq */
                number = gsl_temp_freq (gsl_get_config ()->kammer_freq,
                                        number - gsl_get_config ()->midi_kammer_note);
              else /* ("Invalid chunk format given: postmodifier `%c'", *ep) */
                number = 0;
            }
        }
      else
        number = str2num (string, 0);
    }
  sfi_value_set_real (out_values++, number);
  return BSE_ERROR_NONE;
}
