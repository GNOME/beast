/* BSE - Bedevilled Sound Engine	-*-mode: c;-*-
 * Copyright (C) 2000-2002 Tim Janik
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307, USA.
 */
#include        <bse/bseplugin.h>
#include        <bse/bseprocedure.h>
#include        <bse/bseitem.h>
#include        <bse/bsecontainer.h>
#include        <bse/bswprivate.h>


AUTHOR	= "Tim Janik <timj@gtk.org>";
CRIGHTS	= "Tim Janik";
DATE	= "2001";


METHOD (BseItem, get-type) {
  HELP	= "Retrive an item's type ID.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_ulong ("type_id", "Type ID", NULL,
			      0, G_MAXULONG, 0,
			      BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;
  
  /* set output parameters */
  g_value_set_ulong (out_values++, G_OBJECT_TYPE (item));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-type-name) {
  HELP	= "Retrieve an item's type name.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_string ("type_name", "Type Name", NULL,
			       NULL,
			       BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;
  
  /* set output parameters */
  g_value_set_string (out_values++, g_type_name (G_OBJECT_TYPE (item)));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-type-blurb) {
  HELP	= "Retrieve an item's type description.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_string ("type_blurb", "Type Blurb", NULL,
			       NULL,
			       BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;
  
  /* set output parameters */
  g_value_set_string (out_values++, bse_type_blurb (G_OBJECT_TYPE (item)));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-parent) {
  HELP	= "Retrive an item's parent.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_object ("parent", "Parent", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;
  
  /* set output parameters */
  g_value_set_object (out_values++, item->parent);
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-project) {
  HELP	= "Retrive an item's project.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_object ("project", "Project", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;
  
  /* set output parameters */
  g_value_set_object (out_values++, bse_item_get_project (item));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-uname-path) {
  HELP	= "Retrieve the project relative uname path for this item.";
  IN	= g_param_spec_object ("item", NULL, NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_string ("uloc_path", NULL, NULL,
			       NULL, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = g_value_get_object (in_values++);
  BseProject *project;

  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;

  project = bse_item_get_project (item);

  /* set output parameters */
  g_value_set_string_take_ownership (out_values++,
				     project ? bse_container_make_upath (BSE_CONTAINER (project), item) : NULL);
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, use) {
  HELP	= "Increment use count to keep an item alive.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_object ("used_item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* action */
  bse_item_use (item);

  /* set output parameters */
  g_value_set_object (out_values++, item);
				     
  return BSE_ERROR_NONE;
}

METHOD (BseItem, unuse) {
  HELP	= "Decrement use count for when an item is not needed anymore.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* action */
  if (item->use_count < 1)
    return BSE_ERROR_NOT_OWNER;

  item->use_count--;
  if (!item->use_count)
    bse_object_unref (item);

  /* set output parameters */
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-name) {
  HELP	= "Retrive an item's name.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_string ("name", "Name", NULL,
			       NULL, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);

  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  g_value_set_string (out_values++, BSE_OBJECT_UNAME (item));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-name-or-type) {
  HELP	= "Retrive an item's name or type if it has no name.";
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_string ("name", "Name", NULL,
			       NULL, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  gchar *name = NULL;

  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  name = BSE_OBJECT_UNAME (item);
  if (name)
    g_value_set_string (out_values++, name);
  else
    g_value_set_string (out_values++, BSE_OBJECT_TYPE_NAME (item));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, common-ancestor) {
  HELP	= "Retrive the common ancestor of two items if there's any.";
  IN	= g_param_spec_object ("item", "Item", "First item",
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_object ("item2", "Item2", "Second item",
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_object ("ancestor", "ancestor", "Common ancestor of both items",
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item  = g_value_get_object (in_values++);
  BseItem *item2 = g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item) || !BSE_IS_ITEM (item2))
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  g_value_set_object (out_values++, bse_item_common_ancestor (item, item2));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, get-seqid) {
  HELP	= ("Retrive an item's sequential ID. The sequential ID depends "
	   "on the item's type an it's position inbetween siblings "
	   "of the same type within it's immediate container.");
  IN	= g_param_spec_object ("item", "Item", NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_uint ("seqid", "Sequential ID", NULL,
			     0, G_MAXINT, 0, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item = (BseItem*) g_value_get_object (in_values++);
  
  /* check parameters */
  if (!BSE_IS_ITEM (item))
    return BSE_ERROR_PROC_PARAM_INVAL;
  
  /* set output parameters */
  g_value_set_uint (out_values++, bse_item_get_seqid (item));
  
  return BSE_ERROR_NONE;
}

METHOD (BseItem, check-is-a) {
  BLURB = "Check whether an item has a certain type.";
  IN    = g_param_spec_object ("item", "Item", "The Item",
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  IN    = g_param_spec_string ("type_name", "Type Name", NULL,
			       NULL, BSE_PARAM_DEFAULT);
  OUT   = g_param_spec_boolean ("is_a", NULL, NULL,
				FALSE, BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *item    = g_value_get_object (in_values++);
  gchar *type_name = g_value_get_string (in_values++);
  GType type;
  gboolean is_a;

  /* check parameters */
  if (!type_name)
    type_name = "";

  /* action */
  type = g_type_from_name (type_name);
  is_a = item && g_type_is_a (G_OBJECT_TYPE (item), type);

  /* set output parameters */
  g_value_set_boolean (out_values++, is_a);

  return BSE_ERROR_NONE;
}

METHOD (BseItem, list-proxies) {
  HELP	= "List possible values for a proxy property of an item.";
  IN	= g_param_spec_object ("item", NULL, NULL,
			       BSE_TYPE_ITEM, BSE_PARAM_DEFAULT);
  IN	= g_param_spec_string ("property", NULL, "Proxy property name",
			       NULL, BSE_PARAM_DEFAULT);
  OUT	= g_param_spec_boxed ("proxy_list", NULL, NULL,
			      BSW_TYPE_ITER_PROXY,
			      BSE_PARAM_DEFAULT);
} BODY (BseProcedureClass *proc,
	const GValue      *in_values,
	GValue            *out_values)
{
  /* extract parameter values */
  BseItem *self     = g_value_get_object (in_values++);
  gchar   *property = g_value_get_string (in_values++);
  BswIterProxy *iter;

  /* check parameters */
  if (!BSE_IS_ITEM (self) || !property)
    return BSE_ERROR_PROC_PARAM_INVAL;

  /* set output parameters */
  iter = bse_item_list_proxies (self, property);
  if (!iter)
    iter = bsw_iter_create (BSW_TYPE_ITER_PROXY, 0);
  g_value_set_boxed_take_ownership (out_values++, iter);

  return BSE_ERROR_NONE;
}
