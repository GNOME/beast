// Licensed GNU LGPL v2.1 or later: http://www.gnu.org/licenses/lgpl.html
#include <bse/bsecategories.hh>
#include <bse/bseprocedure.hh>
#include <bse/bseplugin.hh>
#include "bsecxxplugin.hh"
#include "bsebuiltin_externs.cc"


AUTHORS	= "Tim Janik <timj@gtk.org>";
LICENSE	= "GNU Lesser General Public License";


PROCEDURE (bse-categories-match-typed, "Categories/Match Typed") {
  HELP  = "List BSE categories according to a pattern and type match.";
  IN	= sfi_pspec_string ("pattern", "Pattern", "Pattern to match category, supports '*' and '?' wildcards.",
			    "*", SFI_PARAM_STANDARD);
  IN	= sfi_pspec_string ("type", "Type", "Base type for categories to conform to.",
			    NULL, SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_boxed ("categories", "Categories", NULL, BSE_TYPE_CATEGORY_SEQ, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  const char *pattern   = sfi_value_get_string (in_values++);
  const char *type_name = sfi_value_get_string (in_values++);
  GType  type     = type_name ? g_type_from_name (type_name) : 0;
  BseCategorySeq *cseq = NULL;

  /* check parameters */
  if (!pattern)
    return Bse::ERROR_PROC_PARAM_INVAL;

  if (type)
    cseq = bse_categories_match_typed (pattern, type);
  if (!cseq)
    cseq = bse_category_seq_new ();

  /* set output parameters */
  bse_value_take_boxed (out_values++, cseq);

  return Bse::ERROR_NONE;
}

PROCEDURE (bse-categories-match, "Categories/Match") {
  HELP  = "List BSE categories according to a pattern match.";
  IN	= sfi_pspec_string ("pattern", "Pattern", "Pattern to match category, supports '*' and '?' wildcards.",
			    "*", SFI_PARAM_STANDARD);
  OUT   = bse_param_spec_boxed ("categories", "Categories", NULL, BSE_TYPE_CATEGORY_SEQ, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  const char *pattern   = sfi_value_get_string (in_values++);
  BseCategorySeq *cseq = NULL;

  /* check parameters */
  if (!pattern)
    return Bse::ERROR_PROC_PARAM_INVAL;

  cseq = bse_categories_match_typed (pattern, 0);
  if (!cseq)
    cseq = bse_category_seq_new ();

  /* set output parameters */
  bse_value_take_boxed (out_values++, cseq);

  return Bse::ERROR_NONE;
}
