// Licensed GNU LGPL v2.1 or later: http://www.gnu.org/licenses/lgpl.html
#include <bse/bseplugin.hh>
#include <bse/bseprocedure.hh>
#include <bse/bsesource.hh>
#include <bse/bseundostack.hh>
#include <bse/bseieee754.hh>
#include <bse/bsemidievent.hh>
#include "bsecxxplugin.hh"
#include "bsebuiltin_externs.cc"


AUTHORS	= "Tim Janik <timj@gtk.org>";
LICENSE = "GNU Lesser General Public License";

METHOD (BseSource, clear-inputs) {
  HELP	= "Disconnect all module inputs.";
  IN	= bse_param_spec_object ("module", "Module", NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *isource = (BseSource*) bse_value_get_object (in_values++);
  BseUndoStack *ustack;

  /* check parameters */
  if (!BSE_IS_SOURCE (isource))
    return Bse::Error::PROC_PARAM_INVAL;

  /* disconnect */
  ustack = bse_item_undo_open (isource, "clear-inputs %s", bse_object_debug_name (isource));
  bse_source_backup_ichannels_to_undo (isource);
  bse_item_push_redo_proc (isource, "clear-inputs");
  bse_item_undo_close (ustack);
  bse_source_clear_ichannels (isource);

  return Bse::Error::NONE;
}

METHOD (BseSource, clear-outputs) {
  HELP	= "Disconnect all module outputs.";
  IN	= bse_param_spec_object ("module", "Module", NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *isource = (BseSource*) bse_value_get_object (in_values++);
  BseUndoStack *ustack;

  /* check parameters */
  if (!BSE_IS_SOURCE (isource))
    return Bse::Error::PROC_PARAM_INVAL;

  /* disconnect */
  ustack = bse_item_undo_open (isource, "clear-outputs %s", bse_object_debug_name (isource));
  bse_source_backup_ochannels_to_undo (isource);
  bse_item_push_redo_proc (isource, "clear-outputs");
  bse_item_undo_close (ustack);
  bse_source_clear_ochannels (isource);

  return Bse::Error::NONE;
}

METHOD (BseSource, get-automation-channel) {
  HELP	= "Get MIDI channel from an automation property.";
  IN	= bse_param_spec_object ("source", NULL, NULL,
				 BSE_TYPE_SOURCE, SFI_PARAM_STANDARD);
  IN    = sfi_pspec_string ("property_name", NULL, "Item property name",
                            NULL, SFI_PARAM_STANDARD);
  OUT   = sfi_pspec_int ("midi_channel", NULL, NULL, 0, 0, BSE_MIDI_MAX_CHANNELS, 1, SFI_PARAM_STANDARD ":scale:unprepared");
}
BODY (BseProcedureClass *proc,
      const GValue      *in_values,
      GValue            *out_values)
{
  /* extract parameter values */
  BseSource *source = (BseSource*) bse_value_get_object (in_values++);
  const char *property = sfi_value_get_string (in_values++);

  /* check parameters */
  if (!BSE_IS_SOURCE (source) || !property)
    return Bse::Error::PROC_PARAM_INVAL;

  /* connect */
  guint midi_channel = 0;
  bse_source_get_automation_property (source, property, &midi_channel, NULL);
  /* set output parameters */
  g_value_set_int (out_values++, midi_channel);

  return Bse::Error::NONE;
}
