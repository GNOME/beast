@DOC-VARIABLE-DEFINITIONS@
name    = GSL-Functions
blurb   = GSL Function Reference
package = BEAST-0.4.1-rc4
date    = 01 Sep 2002
image   = gsl-functions

@DOC-TITLE@
GSL-Functions

@DOC-HEAD@
GSL-Functions 01 Sep 2002 BEAST-0.4.1-rc4

@DOC-NAME@
GSL-Functions - GSL Function Reference

@DOC-SYNOPSIS@
@STRONG gsl_ring_split@ (@EMPH head1@, @EMPH head2@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 16

@DOC-VARIABLE-DEFINITIONS@
type = GslRing*
typeraw = GslRing*
@DOC-PARAMETER@
head1
@DOC-PARDESC@
a non-empty ring

@DOC-VARIABLE-DEFINITIONS@
type = GslRing*
typeraw = GslRing*
@DOC-PARAMETER@
head2
@DOC-PARDESC@
a ring node different from @EMPH head1@ contained in @EMPH head1@

@DOC-VARIABLE-DEFINITIONS@
retspace = 16

@DOC-RETURNS@
@EMPH head2@ for convenience

@DOC-DESCRIPTION@
Split a ring into two parts, starting the second ring with @EMPH head2@. @EMPH head2@ must therefore be non-NULL and must be contained in the ring formed by @EMPH head1@.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_wakeup@ (@EMPH thread@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslThread*
typeraw = GslThread*
@DOC-PARAMETER@
thread
@DOC-PARDESC@
thread to wake up

@DOC-VARIABLE-DEFINITIONS@
retspace = 19


@DOC-DESCRIPTION@
Wake up a currently sleeping thread. In practice, this function simply causes the next call to @STRONG gsl_thread_sleep()@ within @EMPH thread@ to last for 0 seconds.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_abort@ (@EMPH thread@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslThread*
typeraw = GslThread*
@DOC-PARAMETER@
thread
@DOC-PARDESC@
thread to abort

@DOC-VARIABLE-DEFINITIONS@
retspace = 19


@DOC-DESCRIPTION@
Abort a currently running thread. This function does not return until the thread in question terminated execution. Note that the thread handle gets invalidated with invocation of @STRONG gsl_thread_abort()@ or @STRONG gsl_thread_queue_abort()@.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_queue_abort@ (@EMPH thread@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslThread*
typeraw = GslThread*
@DOC-PARAMETER@
thread
@DOC-PARDESC@
thread to abort

@DOC-VARIABLE-DEFINITIONS@
retspace = 19


@DOC-DESCRIPTION@
Same as @STRONG gsl_thread_abort()@, but returns as soon as possible, even if thread hasn't stopped execution yet. Note that the thread handle gets invalidated with invocation of @STRONG gsl_thread_abort()@ or @STRONG gsl_thread_queue_abort()@.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_aborted@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
@EMPH TRUE@ if the thread should abort execution

@DOC-DESCRIPTION@
Find out if the currently running thread should be aborted (the thread is supposed to return from its main thread function).  
@DOC-SYNOPSIS@
@STRONG gsl_thread_sleep@ (@EMPH max_msec@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = glong\ 
typeraw = glong 
@DOC-PARAMETER@
max_msec
@DOC-PARDESC@
maximum amount of milli seconds to sleep (-1 for infinite time)

@DOC-VARIABLE-DEFINITIONS@
retspace = 17

@DOC-RETURNS@
@EMPH TRUE@ if the thread should continue execution

@DOC-DESCRIPTION@
Sleep for the amount of time given. This function may get interrupted by wakeup or abort requests, it returns whether the thread is supposed to continue execution after waking up. This function also processes remaining data from the thread's poll fd.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_awake_after@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
RETURNS: GPollFD for the current thread Get the GPollfd for the current thread which is used to signal thread wakeups (e.g. due to @STRONG gsl_thread_abort()@ or @STRONG gsl_thread_wakeup()@).  
@DOC-SYNOPSIS@
@STRONG gsl_thread_awake_after@ (@EMPH tick_stamp@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 21

@DOC-VARIABLE-DEFINITIONS@
type = guint64\ 
typeraw = guint64 
@DOC-PARAMETER@
tick_stamp
@DOC-PARDESC@
tick stamp update to trigger wakeup

@DOC-VARIABLE-DEFINITIONS@
retspace = 21


@DOC-DESCRIPTION@
Wakeup the currently running thread after the global tick stamp (see @STRONG gsl_tick_stamp()@) has been updated to @EMPH tick_stamp@. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
@DOC-SYNOPSIS@
@STRONG gsl_thread_awake_before@ (@EMPH tick_stamp@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 21

@DOC-VARIABLE-DEFINITIONS@
type = guint64\ 
typeraw = guint64 
@DOC-PARAMETER@
tick_stamp
@DOC-PARDESC@
tick stamp update to trigger wakeup

@DOC-VARIABLE-DEFINITIONS@
retspace = 21


@DOC-DESCRIPTION@
Wakeup the currently running thread upon the last global tick stamp update (see @STRONG gsl_tick_stamp()@) that happens prior to updating the global tick stamp to @EMPH tick_stamp@. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
@DOC-SYNOPSIS@
@STRONG gsl_tick_stamp@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
GSL's execution tick stamp as unsigned 64bit integer

@DOC-DESCRIPTION@
Retrive the GSL global tick stamp. GSL increments its global tick stamp at certain intervals, by specific amounts (refer to @STRONG gsl_engine_init()@ for further details). The tick stamp is a non-wrapping, unsigned 64bit integer greater than 0. Threads can schedule sleep interruptions at certain tick stamps with @STRONG gsl_thread_awake_after()@ and @STRONG gsl_thread_awake_before()@. Tick stamp updating occours at GSL engine block processing boundaries, so code that can guarantee to not run across those boundaries (for instance @STRONG GslProcessFunc()@ functions) may use the macro @EMPH GSL_TICK_STAMP@ to retrive the current tick in a faster manner (not involving mutex locking). See also @STRONG gsl_module_tick_stamp()@. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_time_system@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
Current system time in micro seconds

@DOC-DESCRIPTION@
Get the current system time in micro seconds. Subsequent calls to this function do not necessarily return growing values. In fact, a second call may return a value smaller than the first call under certainsystem conditions. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_tick_stamp_last@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
Current tick stamp and system time in micro seconds

@DOC-DESCRIPTION@
Get the system time of the last GSL global tick stamp update. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_data_handle_new_cut@ (@EMPH src_handle@, @EMPH cut_offset@, @EMPH n_cut_values@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 29

@DOC-VARIABLE-DEFINITIONS@
type = GslDataHandle*
typeraw = GslDataHandle*
@DOC-PARAMETER@
src_handle
@DOC-PARDESC@
source GslDataHandle

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ \ \ \ \ \ 
typeraw = GslLong       
@DOC-PARAMETER@
cut_offset
@DOC-PARDESC@
offset of gap into @EMPH src_handle@

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ \ \ \ \ \ 
typeraw = GslLong       
@DOC-PARAMETER@
n_cut_values
@DOC-PARDESC@
length of gap in @EMPH src_handle@

@DOC-VARIABLE-DEFINITIONS@
retspace = 29

@DOC-RETURNS@
a newly created data handle

@DOC-DESCRIPTION@
Create a new data handle containing the contents of @EMPH src_handle@ minus @EMPH n_cut_values@ at offset @EMPH cut_offset@.  
@DOC-SYNOPSIS@
@STRONG gsl_data_handle_new_crop@ (@EMPH src_handle@, @EMPH n_head_cut@, @EMPH n_tail_cut@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 27

@DOC-VARIABLE-DEFINITIONS@
type = GslDataHandle*
typeraw = GslDataHandle*
@DOC-PARAMETER@
src_handle
@DOC-PARDESC@
source GslDataHandle

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ \ \ \ \ \ 
typeraw = GslLong       
@DOC-PARAMETER@
n_head_cut
@DOC-PARDESC@
number of values to cut at data handle head

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ \ \ \ \ \ 
typeraw = GslLong       
@DOC-PARAMETER@
n_tail_cut
@DOC-PARDESC@
number of values to cut at data handle tail

@DOC-VARIABLE-DEFINITIONS@
retspace = 27

@DOC-RETURNS@
a newly created data handle

@DOC-DESCRIPTION@
Create a new data handle containing the contents of @EMPH src_handle@ minus @EMPH n_head_cut@ values at the start and @EMPH n_tail_cut@ values at the end.  
@DOC-SYNOPSIS@
@STRONG gsl_data_find_block@ (@EMPH handle@, @EMPH n_values@, @EMPH values@, @EMPH epsilon@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = GslDataHandle*
typeraw = GslDataHandle*
@DOC-PARAMETER@
handle
@DOC-PARDESC@
an open GslDataHandle

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ \ \ 
typeraw = guint         
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
amount of values to look for

@DOC-VARIABLE-DEFINITIONS@
type = const\ gfloat*\ 
typeraw = const gfloat* 
@DOC-PARAMETER@
values
@DOC-PARDESC@
values to find

@DOC-VARIABLE-DEFINITIONS@
type = gfloat\ \ \ \ \ \ \ \ 
typeraw = gfloat        
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
maximum difference upon comparisions

@DOC-VARIABLE-DEFINITIONS@
retspace = 25

@DOC-RETURNS@
position of values in data handle or -1

@DOC-DESCRIPTION@
Find the position of a block of values within a data handle, where all values compare to the reference values with a delta smaller than epsilon.  
@DOC-SYNOPSIS@
@STRONG gsl_module_new@ (@EMPH klass@, @EMPH user_data@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 27

@DOC-VARIABLE-DEFINITIONS@
type = const\ GslClass*
typeraw = const GslClass*
@DOC-PARAMETER@
klass
@DOC-PARDESC@
the GslClass which determines the module's behaviour

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ \ \ \ 
typeraw = gpointer       
@DOC-PARAMETER@
user_data
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
retspace = 27

@DOC-RETURNS@
a newly created module

@DOC-DESCRIPTION@
Create a new module with methods specified in @EMPH klass@ and a user_data field set to @EMPH user_data@. The returned module can then be integrated into the engine with @STRONG gsl_job_integrate()@. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_module_tick_stamp@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
a GSL engine module

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
the module's tick stamp, indicating its process status

@DOC-DESCRIPTION@
Any thread may call this function on a valid engine module. The module specific tick stamp is updated to @STRONG gsl_tick_stamp()@ + @EMPH n_values@ every time its @STRONG GslProcessFunc()@ function was called. See also @STRONG gsl_tick_stamp()@. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_integrate@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
The module to integrate

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job to integrate @EMPH module@ into the engine. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_discard@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
The module to discard

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which removes @EMPH module@ from the engine and destroys it. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_kill_inputs@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
Module with input streams

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which causes all connected input streams of @EMPH module@ to be disconnected, like it's done upon discarding the module. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_kill_outputs@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
Module with output streams

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which causes all connected output streams of @EMPH module@ to be disconnected, like it's done upon discarding the module. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_connect@ (@EMPH src_module@, @EMPH src_ostream@, @EMPH dest_module@, @EMPH dest_istream@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
src_module
@DOC-PARDESC@
Module with output stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
src_ostream
@DOC-PARDESC@
Index of output stream of @EMPH src_module@

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
dest_module
@DOC-PARDESC@
Module with unconnected input stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
dest_istream
@DOC-PARDESC@
Index of input stream of @EMPH dest_module@

@DOC-VARIABLE-DEFINITIONS@
retspace = 25

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which connects the ouput stream @EMPH src_ostream@ of module @EMPH src_module@ to the input stream @EMPH dest_istream@ of module @EMPH dest_module@ (it is an error if the input stream is already connected by the time the job is executed). This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_jconnect@ (@EMPH src_module@, @EMPH src_ostream@, @EMPH dest_module@, @EMPH dest_jstream@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
src_module
@DOC-PARDESC@
Module with output stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
src_ostream
@DOC-PARDESC@
Index of output stream of @EMPH src_module@

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
dest_module
@DOC-PARDESC@
Module with unconnected joint input stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
dest_jstream
@DOC-PARDESC@
Index of joint input stream of @EMPH dest_module@

@DOC-VARIABLE-DEFINITIONS@
retspace = 25

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which connects the ouput stream @EMPH src_ostream@ of module @EMPH src_module@ to the joint input stream @EMPH dest_istream@ of module @EMPH dest_module@. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_disconnect@ (@EMPH dest_module@, @EMPH dest_istream@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
dest_module
@DOC-PARDESC@
Module with connected input stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
dest_istream
@DOC-PARDESC@
Index of input stream of @EMPH dest_module@

@DOC-VARIABLE-DEFINITIONS@
retspace = 25

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which causes the input stream @EMPH dest_istream@ of @EMPH dest_module@ to be disconnected (it is an error if the input stream isn't connected by the time the job is executed). This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_jdisconnect@ (@EMPH dest_module@, @EMPH dest_jstream@, @EMPH src_module@, @EMPH src_ostream@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
dest_module
@DOC-PARDESC@
Module with connected input stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
dest_jstream
@DOC-PARDESC@
Index of input stream of @EMPH dest_module@

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
src_module
@DOC-PARDESC@
Module with output stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint	    
@DOC-PARAMETER@
src_ostream
@DOC-PARDESC@
Index of output stream of @EMPH src_module@

@DOC-VARIABLE-DEFINITIONS@
retspace = 25

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which causes the joint input stream @EMPH dest_jstream@ of @EMPH dest_module@ to be disconnected from the output stream @EMPH src_ostream@ of @EMPH src_module@ (it is an error if this connection isn't established by the time the job is executed). Beware, the order of @EMPH dest_module@ and @EMPH src_module@ is different from @STRONG gsl_job_jconnect()@. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG GslAccessFunc@ (@EMPH module@, @EMPH data@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 9

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
module
@DOC-PARDESC@
Module to operate on

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
data
@DOC-PARDESC@
Accessor data

@DOC-VARIABLE-DEFINITIONS@
retspace = 9


@DOC-DESCRIPTION@
The GslAccessFunc is a user supplied callback function which can access a module in times it is not processing. Accessors are usually used to either read out a module's current state, or to modify its state. An accessor may only operate on the @EMPH data@ and the @EMPH module@ passed in to it.  
@DOC-SYNOPSIS@
@STRONG gsl_job_access@ (@EMPH module@, @EMPH access_func@, @EMPH data@, @EMPH free_func@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 28

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*\ \ \ \ 
typeraw = GslModule*    
@DOC-PARAMETER@
module
@DOC-PARDESC@
The module to access

@DOC-VARIABLE-DEFINITIONS@
type = GslAccessFunc\ 
typeraw = GslAccessFunc 
@DOC-PARAMETER@
access_func
@DOC-PARDESC@
The accessor function

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ \ \ 
typeraw = gpointer      
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data passed in to the accessor

@DOC-VARIABLE-DEFINITIONS@
type = GslFreeFunc\ \ \ 
typeraw = GslFreeFunc   
@DOC-PARAMETER@
free_func
@DOC-PARDESC@
Function to free @EMPH data@

@DOC-VARIABLE-DEFINITIONS@
retspace = 28

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which will invoke @EMPH access_func@ on @EMPH module@ with @EMPH data@ when the transaction queue is processed to modify the module's state. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_flow_job_access@ (@EMPH module@, @EMPH tick_stamp@, @EMPH access_func@, @EMPH data@, @EMPH free_func@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 28

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*\ \ \ \ 
typeraw = GslModule*    
@DOC-PARAMETER@
module
@DOC-PARDESC@
The module to access

@DOC-VARIABLE-DEFINITIONS@
type = guint64\ \ \ \ \ \ \ 
typeraw = guint64       
@DOC-PARAMETER@
tick_stamp
@DOC-PARDESC@
Engine time stamp

@DOC-VARIABLE-DEFINITIONS@
type = GslAccessFunc\ 
typeraw = GslAccessFunc 
@DOC-PARAMETER@
access_func
@DOC-PARDESC@
The accessor function

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ \ \ 
typeraw = gpointer      
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data passed in to the accessor

@DOC-VARIABLE-DEFINITIONS@
type = GslFreeFunc\ \ \ 
typeraw = GslFreeFunc   
@DOC-PARAMETER@
free_func
@DOC-PARDESC@
Function to free @EMPH data@

@DOC-VARIABLE-DEFINITIONS@
retspace = 28

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which inserts @EMPH access_func@ with @EMPH data@ into the flow job queue of @EMPH module@. Flow jobs are jobs with limited impact on modules, which are executed during flow system progress at specific times. Once the time stamp counter of @EMPH module@ passed @EMPH tick_stamp@, @EMPH access_func@ is called to modify the module's state. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_suspend@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
Module not currently suspended

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which suspends the @EMPH module@ and all it's input modules which don't have other non-suspended output connections. Suspension of a module prevents it's @STRONG process()@ method from being called, it's outputs are simply filled with zero's instead. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_flow_job_resume@ (@EMPH module@, @EMPH tick_stamp@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 23

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
Module not currently suspended

@DOC-VARIABLE-DEFINITIONS@
type = guint64\ \ \ 
typeraw = guint64   
@DOC-PARAMETER@
tick_stamp
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
retspace = 23

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which inserts a resumption event into the flow job queue of @EMPH module@. Flow jobs are jobs with limited impact on modules, which are executed during flow system progress at specific times. Once the time stamp counter of @EMPH module@ passed @EMPH tick_stamp@, its @STRONG reset()@ method is called and the module is resumed, causing it's @STRONG process()@ method to be called again. Resuming a module also resumes all input modules it has, unless those were explicitely suspended via @STRONG gsl_job_suspend()@. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG GslPollFunc@ (@EMPH data@, @EMPH n_values@, @EMPH timeout_p@, @EMPH n_fds@, @EMPH fds@, @EMPH revents_filled@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data of poll function

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Minimum number of values the engine wants to process

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
timeout_p
@DOC-PARDESC@
Location of timeout value

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_fds
@DOC-PARDESC@
Number of file descriptors used for polling

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
fds
@DOC-PARDESC@
File descriptors to be used for polling

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
revents_filled
@DOC-PARDESC@
Indicates whether @EMPH fds@ actually have their ->revents field filled with valid data.

@DOC-VARIABLE-DEFINITIONS@
retspace = 17

@DOC-RETURNS@
A boolean value indicating whether the engine should process data right now

@DOC-DESCRIPTION@
The GslPollFunc is a user supplied callback function which can be hooked into the GSL engine. The engine uses the poll functions to determine whether processing of @EMPH n_values@ in its module network is necessary. In order for the poll functions to react to extern events, such as device driver status changes, the engine will @STRONG poll(2)@ the @EMPH fds@ of the poll function and invoke the callback with @EMPH revents_filled@==@EMPH TRUE@ if any of its @EMPH fds@ changed state. The callback may also be invoked at other random times with @EMPH revents_filled@=@EMPH FALSE@. It is supposed to return @EMPH TRUE@ if network processing is currently necessary, and @EMPH FALSE@ if not. If @EMPH FALSE@ is returned, @EMPH timeout_p@ may be filled with the number of milliseconds the engine should use for polling at maximum.  
@DOC-SYNOPSIS@
@STRONG gsl_job_add_poll@ (@EMPH poll_func@, @EMPH data@, @EMPH free_func@, @EMPH n_fds@, @EMPH fds@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 26

@DOC-VARIABLE-DEFINITIONS@
type = GslPollFunc\ \ \ 
typeraw = GslPollFunc   
@DOC-PARAMETER@
poll_func
@DOC-PARDESC@
Poll function to add

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ \ \ 
typeraw = gpointer      
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data of poll function

@DOC-VARIABLE-DEFINITIONS@
type = GslFreeFunc\ \ \ 
typeraw = GslFreeFunc   
@DOC-PARAMETER@
free_func
@DOC-PARDESC@
Function to free @EMPH data@

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ \ \ 
typeraw = guint         
@DOC-PARAMETER@
n_fds
@DOC-PARDESC@
Number of poll file descriptors

@DOC-VARIABLE-DEFINITIONS@
type = const\ GPollFD*
typeraw = const GPollFD*
@DOC-PARAMETER@
fds
@DOC-PARDESC@
File descriptors to @STRONG select(2)@ or @STRONG poll(2)@ on

@DOC-VARIABLE-DEFINITIONS@
retspace = 26

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which adds a poll function to the engine. The poll function is used by the engine to determine whether processing is currently necessary. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_remove_poll@ (@EMPH poll_func@, @EMPH data@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 24

@DOC-VARIABLE-DEFINITIONS@
type = GslPollFunc\ 
typeraw = GslPollFunc 
@DOC-PARAMETER@
poll_func
@DOC-PARDESC@
Poll function to remove

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ 
typeraw = gpointer    
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data of poll function

@DOC-VARIABLE-DEFINITIONS@
retspace = 24

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which removes a previously inserted poll function from the engine. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_job_debug@ (@EMPH debug@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 20

@DOC-VARIABLE-DEFINITIONS@
type = const\ gchar*
typeraw = const gchar*
@DOC-PARAMETER@
debug
@DOC-PARDESC@
Debug message

@DOC-VARIABLE-DEFINITIONS@
retspace = 20

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which issues @EMPH debug@ message when the job is executed. This function is meant for debugging purposes during development phase only and shouldn't be used in production code. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_trans_open@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
Newly opened empty transaction

@DOC-DESCRIPTION@
Open up a new transaction to commit jobs to the GSL engine. While the distinct functions to operate on a transaction are MT-safe, the caller has to take measures himself, to assure that only one function operates on the transaction at a time. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_trans_add@ (@EMPH trans@, @EMPH job@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslTrans*
typeraw = GslTrans*
@DOC-PARAMETER@
trans
@DOC-PARDESC@
Opened transaction

@DOC-VARIABLE-DEFINITIONS@
type = GslJob*\ \ 
typeraw = GslJob*  
@DOC-PARAMETER@
job
@DOC-PARDESC@
Job to add

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Append a job to an opened transaction. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_trans_commit@ (@EMPH trans@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslTrans*
typeraw = GslTrans*
@DOC-PARAMETER@
trans
@DOC-PARDESC@
Opened transaction

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Close the transaction and commit it to the engine. The engine will execute the jobs contained in this transaction as soon as it has completed its current processing cycle. The jobs will be executed in the exact order they were added to the transaction.  
@DOC-SYNOPSIS@
@STRONG gsl_trans_dismiss@ (@EMPH trans@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslTrans*
typeraw = GslTrans*
@DOC-PARAMETER@
trans
@DOC-PARDESC@
Opened transaction

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Close and discard the transaction, causes destruction of all jobs currently contained in it and prevents their execution. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_transact@ (@EMPH job@, @EMPH ...@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 6

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
job
@DOC-PARDESC@
First job

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
...
@DOC-PARDESC@
@EMPH NULL@ terminated job list

@DOC-VARIABLE-DEFINITIONS@
retspace = 6


@DOC-DESCRIPTION@
Convenience function which openes up a new transaction, collects the @EMPH NULL@ terminated job list passed to the function, and commits the transaction. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_module_new_virtual@ (@EMPH n_iostreams@, @EMPH user_data@, @EMPH free_data@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 26

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ 
typeraw = guint       
@DOC-PARAMETER@
n_iostreams
@DOC-PARDESC@
number of input and output streams

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ 
typeraw = gpointer    
@DOC-PARAMETER@
user_data
@DOC-PARDESC@
user data, stored in module->user_data

@DOC-VARIABLE-DEFINITIONS@
type = GslFreeFunc\ 
typeraw = GslFreeFunc 
@DOC-PARAMETER@
free_data
@DOC-PARDESC@
function to free user_data when the module is discarded

@DOC-VARIABLE-DEFINITIONS@
retspace = 26

@DOC-RETURNS@
a newly created module

@DOC-DESCRIPTION@
Create a new virtual module which has @EMPH n_iostreams@ input streams and @EMPH n_iostreams@ output streams. Simply put, virtual modules just pass all input stream signals through to the corresponsding output stream. However, they are cheaper to compute than a literal module implementation that just passes through all data in its @STRONG progress()@ method, because the connections can be virtualized in a connection optimization stage during scheduling, so that they don't end up in the list of modules which need to be processed during calculation phase. Beware though, flow jobs may not be scheduled on virtual modules (thusly, suspend jobs cannot be queued on them either), as virtual modules are ignored during calculation phase. They do, however, work just like ordinary modules with regards to suspension propagation, so the suspension state from output modules does only propagate across the virtual module to its input modules, if all its outputs are suspended. Instead of a single virtual module with multiple input/output streams, multiple virtual modules can be used if suspension is desired to propagate per stream. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_init@ (@EMPH run_threaded@, @EMPH block_size@, @EMPH sample_freq@, @EMPH sub_sample_mask@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 27

@DOC-VARIABLE-DEFINITIONS@
type = gboolean\ 
typeraw = gboolean 
@DOC-PARAMETER@
run_threaded
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ 
typeraw = guint    
@DOC-PARAMETER@
block_size
@DOC-PARDESC@
number of values to process block wise

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ 
typeraw = guint    
@DOC-PARAMETER@
sample_freq
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ 
typeraw = guint    
@DOC-PARAMETER@
sub_sample_mask
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
retspace = 27


@DOC-DESCRIPTION@
Initialize the GSL engine, this function must be called prior to any other engine related function and can only be invoked once. The @EMPH block_size@ determines the amount by which the global tick stamp (see @STRONG gsl_tick_stamp()@) is updated everytime the whole module network completed processing @EMPH block_size@ values.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_dispatch@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
Perform necessary work the engine has to handle in the user thread. This function may only be called from the user thread, since it will invoke @STRONG GslFreeFunc()@ functions (see @STRONG gsl_engine_garbage_collect()@) and do other things which are guranteed to be executed in the user thread.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_tick_stamp_from_systime@ (@EMPH systime@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 18

@DOC-VARIABLE-DEFINITIONS@
type = guint64\ 
typeraw = guint64 
@DOC-PARAMETER@
systime
@DOC-PARDESC@
System time in micro seconds.

@DOC-VARIABLE-DEFINITIONS@
retspace = 18

@DOC-RETURNS@
Engine tick stamp value

@DOC-DESCRIPTION@
Depending on the engine's sample frequency and the time of the last global tick stamp update, calculate the corresponding engine tick stamp from a given system time. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_wait_on_trans@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
Wait until all pending transactions have been processed by the GSL Engine. This function, when done waiting, will run a garbage collection cycle before returning (see @STRONG gsl_engine_garbage_collect()@).  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftac@ (@EMPH n_values@, @EMPH ri_values_in@, @EMPH ri_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 16

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_in
@DOC-PARDESC@
Complex sample values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_out
@DOC-PARDESC@
Complex frequency values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 16


@DOC-DESCRIPTION@
This function performs a decimation in time fourier transformation in forward direction, where the input values are equidistant sampled data, and the output values contain the frequency proportions of the input. The input and output arrays are complex values with real and imaginery portions interleaved, adressable in the range [0..2*n_values-1], where n_values must be a power of two. Frequencies are stored in-order, the K-th output corresponds to the frequency K/n_values. (If you want to interpret negative frequencies, note that the frequencies -K/n_values and (n_values-K)/n_values are equivalent). Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftsc@ (@EMPH n_values@, @EMPH ri_values_in@, @EMPH ri_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 16

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_in
@DOC-PARDESC@
Complex frequency values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_out
@DOC-PARDESC@
Complex sample values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 16


@DOC-DESCRIPTION@
This function performs a decimation in time fourier transformation in backwards direction with normalization. As such, this function represents the counterpart to @STRONG gsl_power2_fftac()@, that is, a value array which is transformed into the frequency domain with @STRONG gsl_power2_fftac()@ can be reconstructed by issuing @STRONG gsl_power2_fftsc()@ on the transform. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftar@ (@EMPH n_values@, @EMPH r_values_in@, @EMPH ri_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 16

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
r_values_in
@DOC-PARDESC@
Real sample values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_out
@DOC-PARDESC@
Complex frequency values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 16


@DOC-DESCRIPTION@
Real valued variant of @STRONG gsl_power2_fftac()@, the input array contains real valued equidistant sampled data [0..n_values-1], and the output array contains the positive frequency half of the complex valued fourier transform. Note, that the complex valued fourier transform H of a purely real valued set of data, satisfies @STRONG H(-f)@ = Conj(@STRONG H(f)@), where @STRONG Conj()@ denotes the complex conjugate, so that just the positive frequency half suffices to describe the entire frequency spectrum. Even so, the resulting n_values/2 complex frequencies are one value off in storage size, but the resulting frequencies @STRONG H(0)@ and @STRONG H(n_values/2)@ are both real valued, so the real portion of @STRONG H(n_values/2)@ is stored in ri_values_out[1] (the imaginery part of @STRONG H(0)@), so that both r_values_in and ri_values_out can be of size n_values. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftsr@ (@EMPH n_values@, @EMPH ri_values_in@, @EMPH r_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 15

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_in
@DOC-PARDESC@
Complex frequency values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
r_values_out
@DOC-PARDESC@
Real sample values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 15


@DOC-DESCRIPTION@
Real valued variant of @STRONG gsl_power2_fftsc()@, counterpart to @STRONG gsl_power2_fftar()@, using the same frequency storage format. A real valued data set transformed into the frequency domain with @STRONG gsl_power2_fftar()@ can be reconstructed using this function. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_hfile_open@ (@EMPH file_name@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 24

@DOC-VARIABLE-DEFINITIONS@
type = const\ gchar*
typeraw = const gchar*
@DOC-PARAMETER@
file_name
@DOC-PARDESC@
name of the file to open

@DOC-VARIABLE-DEFINITIONS@
retspace = 24

@DOC-RETURNS@
a new opened @STRONG GslHFile@ or NULL if an error occoured (errno set)

@DOC-DESCRIPTION@
Open a file for reading and return the associated GSL hashed file. The motivation for using a @STRONG GslHFile@ over normal unix file descriptors is to reduce the amount of opened unix file descriptors and to ensure thread safety upon reading offset relative byte blocks. Multiple open @STRONG GslHFiles@ with equal file names will share a single unix file descriptor as long as the file wasn't modified meanwhile. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_hfile_close@ (@EMPH hfile@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslHFile*
typeraw = GslHFile*
@DOC-PARAMETER@
hfile
@DOC-PARDESC@
valid @STRONG GslHFile@

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Close and destroy a @STRONG GslHFile@. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_hfile_pread@ (@EMPH hfile@, @EMPH offset@, @EMPH n_bytes@, @EMPH bytes@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslHFile*
typeraw = GslHFile*
@DOC-PARAMETER@
hfile
@DOC-PARDESC@
valid GslHFile

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ 
typeraw = GslLong  
@DOC-PARAMETER@
offset
@DOC-PARDESC@
offset in bytes within 0 and file end

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ 
typeraw = GslLong  
@DOC-PARAMETER@
n_bytes
@DOC-PARDESC@
number of bytes to read

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ 
typeraw = gpointer 
@DOC-PARAMETER@
bytes
@DOC-PARDESC@
buffer to store read bytes

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
amount of bytes read or -1 if an error occoured (errno set)

@DOC-DESCRIPTION@
Read a block of bytes from a GslHFile. This function is MT-safe and may be called from any thread.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_open@ (@EMPH file_name@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 24

@DOC-VARIABLE-DEFINITIONS@
type = const\ gchar*
typeraw = const gchar*
@DOC-PARAMETER@
file_name
@DOC-PARDESC@
name of the file to open

@DOC-VARIABLE-DEFINITIONS@
retspace = 24

@DOC-RETURNS@
a new opened @STRONG GslRFile@ or NULL if an error occoured (errno set)

@DOC-DESCRIPTION@
Open a file for reading and create a GSL read only file handle for it. The motivation for using a @STRONG GslRFile@ over normal unix files is to reduce the amount of opened unix file descriptors by using a @STRONG GslHFile@ for the actual IO.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_name@ (@EMPH rfile@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslRFile*
typeraw = GslRFile*
@DOC-PARAMETER@
rfile
@DOC-PARDESC@
valid @STRONG GslRFile@

@DOC-VARIABLE-DEFINITIONS@
retspace = 17

@DOC-RETURNS@
the file name used to open this file

@DOC-DESCRIPTION@
Retrive the file name used to open @EMPH rfile@.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_seek_set@ (@EMPH rfile@, @EMPH offset@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 18

@DOC-VARIABLE-DEFINITIONS@
type = GslRFile*
typeraw = GslRFile*
@DOC-PARAMETER@
rfile
@DOC-PARDESC@
valid @STRONG GslRFile@

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ 
typeraw = GslLong  
@DOC-PARAMETER@
offset
@DOC-PARDESC@
new seek position within 0 and @STRONG gsl_rfile_length()@+1

@DOC-VARIABLE-DEFINITIONS@
retspace = 18

@DOC-RETURNS@
resulting position within 0 and @STRONG gsl_rfile_length()@+1

@DOC-DESCRIPTION@
Set the current @STRONG GslRFile@ seek position.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_position@ (@EMPH rfile@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslRFile*
typeraw = GslRFile*
@DOC-PARAMETER@
rfile
@DOC-PARDESC@
valid @STRONG GslRFile@

@DOC-VARIABLE-DEFINITIONS@
retspace = 17

@DOC-RETURNS@
current position within 0 and @STRONG gsl_rfile_length()@

@DOC-DESCRIPTION@
Retrive the current @STRONG GslRFile@ seek position.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_length@ (@EMPH rfile@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslRFile*
typeraw = GslRFile*
@DOC-PARAMETER@
rfile
@DOC-PARDESC@
valid @STRONG GslRFile@

@DOC-VARIABLE-DEFINITIONS@
retspace = 17

@DOC-RETURNS@
total length of the @STRONG GslRFile@ in bytes

@DOC-DESCRIPTION@
Retrive the file length of @EMPH rfile@ in bytes.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_pread@ (@EMPH rfile@, @EMPH offset@, @EMPH n_bytes@, @EMPH bytes@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslRFile*
typeraw = GslRFile*
@DOC-PARAMETER@
rfile
@DOC-PARDESC@
valid GslRFile

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ 
typeraw = GslLong  
@DOC-PARAMETER@
offset
@DOC-PARDESC@
offset in bytes within 0 and @STRONG gsl_rfile_length()@

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ 
typeraw = GslLong  
@DOC-PARAMETER@
n_bytes
@DOC-PARDESC@
number of bytes to read

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ 
typeraw = gpointer 
@DOC-PARAMETER@
bytes
@DOC-PARDESC@
buffer to store read bytes

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
amount of bytes read or -1 if an error occoured (errno set)

@DOC-DESCRIPTION@
Read a block of bytes from a GslRFile at a specified position.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_read@ (@EMPH rfile@, @EMPH n_bytes@, @EMPH bytes@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslRFile*
typeraw = GslRFile*
@DOC-PARAMETER@
rfile
@DOC-PARDESC@
valid GslRFile

@DOC-VARIABLE-DEFINITIONS@
type = GslLong\ \ 
typeraw = GslLong  
@DOC-PARAMETER@
n_bytes
@DOC-PARDESC@
number of bytes to read

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ 
typeraw = gpointer 
@DOC-PARAMETER@
bytes
@DOC-PARDESC@
buffer to store read bytes

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
amount of bytes read or -1 if an error occoured (errno set)

@DOC-DESCRIPTION@
Read a block of bytes from a GslRFile from the current seek position and advance the seek position.  
@DOC-SYNOPSIS@
@STRONG gsl_rfile_close@ (@EMPH rfile@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslRFile*
typeraw = GslRFile*
@DOC-PARAMETER@
rfile
@DOC-PARDESC@
valid @STRONG GslRFile@

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Close and destroy a @STRONG GslRFile@.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_steepness_db@ (@EMPH iorder@, @EMPH c_freq@, @EMPH epsilon@, @EMPH stopband_db@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 27

@DOC-VARIABLE-DEFINITIONS@
type = unsigned\ int\ 
typeraw = unsigned int 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
c_freq
@DOC-PARDESC@
passband cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
stopband_db
@DOC-PARDESC@
reduction in stopband in dB (>= 0)

@DOC-VARIABLE-DEFINITIONS@
retspace = 27


@DOC-DESCRIPTION@
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on the ripple residue in the stop band.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_steepness@ (@EMPH iorder@, @EMPH c_freq@, @EMPH epsilon@, @EMPH residue@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 23

@DOC-VARIABLE-DEFINITIONS@
type = unsigned\ int\ 
typeraw = unsigned int 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
c_freq
@DOC-PARDESC@
passband cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
residue
@DOC-PARDESC@
maximum of transfer function in stopband (0..1)

@DOC-VARIABLE-DEFINITIONS@
retspace = 23


@DOC-DESCRIPTION@
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on ripple residue in the stop band.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_lp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at cutoff frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth lowpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_lp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at cutoff frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 lowpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_lp@ (@EMPH iorder@, @EMPH freq@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
passband cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness (c_freq * steepness < pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 lowpass filter. To gain a transition band between freq1 and freq2, pass arguements @EMPH freq@=freq1 and @EMPH steepness@=freq2/freq1. To specify the transition band width in fractions of octaves, pass @EMPH steepness@=2^octave_fraction.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_hp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
passband frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth highpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_hp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
passband frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 highpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_hp@ (@EMPH iorder@, @EMPH freq@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
stopband frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 highpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_bp@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth bandpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_bp@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 bandpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_bp@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness factor

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 bandpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_bs@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth bandstop filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_bs@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 bandstop filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_bs@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness factor

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 bandstop filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_fir_approx@ (@EMPH iorder@, @EMPH freq@, @EMPH value@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 9

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
order of the filter (must be oven, >= 2)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
the frequencies of the transfer function

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
value
@DOC-PARDESC@
the desired value of the transfer function

@DOC-VARIABLE-DEFINITIONS@
retspace = 9


@DOC-DESCRIPTION@
Approximates a given transfer function with an iorder-coefficient FIR filter. It is recommended to provide enough frequency values, so that @EMPH n_points@ >= @EMPH iorder@.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_sine_scan@ (@EMPH order@, @EMPH a@, @EMPH b@, @EMPH freq@, @EMPH n_values@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ \ \ 
typeraw = guint         
@DOC-PARAMETER@
order
@DOC-PARDESC@
order of the iir filter

@DOC-VARIABLE-DEFINITIONS@
type = const\ gdouble*
typeraw = const gdouble*
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients of the filter a[0..order]

@DOC-VARIABLE-DEFINITIONS@
type = const\ gdouble*
typeraw = const gdouble*
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients of the filter b[0..order]

@DOC-VARIABLE-DEFINITIONS@
type = gdouble\ \ \ \ \ \ \ 
typeraw = gdouble       
@DOC-PARAMETER@
freq
@DOC-PARDESC@
frequency to test

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ \ \ 
typeraw = guint         
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
number of samples

@DOC-VARIABLE-DEFINITIONS@
retspace = 25


@DOC-DESCRIPTION@
This function sends a sine signal of the desired frequency through an IIR filter, to test the value of the transfer function at a given point. It uses gsl_iir_filter_eval to do so.  Compared to a "mathematical approach" of finding the transfer function, this function makes it possible to see the effects of finite arithmetic during filter evaluation.  The first half of the output signal is not considered, since a lot of IIR filters have a transient phase where also overshoot is possible.  For n_values, you should specify a reasonable large value. It should be a lot larger than the filter order, and large enough to let the input signal become (close to) 1.0 multiple times.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_garbage_collect@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
GSL Engine user thread function. Collects processed jobs and transactions from the engine and frees them. This involves callback invocation of @STRONG GslFreeFunc()@ functions, e.g. from @STRONG gsl_job_access()@ or @STRONG gsl_flow_job_access()@ jobs. This function may only be called from the user thread, as @STRONG GslFreeFunc()@ functions are guranteed to be executed in the user thread.  
@DOC-SYNOPSIS@
@STRONG gsl_signal_exp2@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
Deprecated in favour of @STRONG gsl_approx_exp2()@.  
@DOC-SYNOPSIS@
@STRONG gsl_approx_exp2@ (@EMPH ex@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
type = float\ 
typeraw = float 
@DOC-PARAMETER@
ex
@DOC-PARDESC@
exponent within [-127..127]

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
y approximating 2^x

@DOC-DESCRIPTION@
Fast approximation of 2 raised to the power of x. Multiplicative error stays below 8e-6 and aproaches zero for integer values of x (i.e. x - floor (x) = 0).  
@DOC-SYNOPSIS@
@STRONG gsl_approx_atan1@ (@EMPH x@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 20

@DOC-VARIABLE-DEFINITIONS@
type = register\ double\ 
typeraw = register double 
@DOC-PARAMETER@
x
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
retspace = 20


@DOC-DESCRIPTION@
Fast @STRONG atan(x)@/(PI/2) approximation, with maximum error < 0.01 and @STRONG gsl_approx_atan1(0)@==0, according to the formula: n1 = -0.41156875521951602506487246309908; n2 = -1.0091272542790025586079663559158; d1 = 0.81901156857081841441890603235599; d2 = 1.0091272542790025586079663559158; @STRONG positive_atan1(x)@ = 1 + (n1 * x + n2) / ((1 + d1 * x) * x + d2);  
@DOC-SYNOPSIS@
@STRONG gsl_approx_atan1_prescale@ (@EMPH boost_amount@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 15

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
boost_amount
@DOC-PARDESC@
boost amount between [0..1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 15

@DOC-RETURNS@
prescale factor for @STRONG gsl_approx_atan1()@

@DOC-DESCRIPTION@
Calculate the prescale factor for @STRONG gsl_approx_atan1(x*prescale)@ from a linear boost factor, where 0.5 amounts to prescale=1.0, 1.0 results in maximum boost and 0.0 results in maximum attenuation.  
@DOC-SYNOPSIS@
@STRONG gsl_approx_qcircle1@ (@EMPH x@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 20

@DOC-VARIABLE-DEFINITIONS@
type = register\ double\ 
typeraw = register double 
@DOC-PARAMETER@
x
@DOC-PARDESC@
x within [0..1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 20

@DOC-RETURNS@
y for circle approximation within [0..1]

@DOC-DESCRIPTION@
Fast approximation of the upper right quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
@DOC-SYNOPSIS@
@STRONG gsl_approx_qcircle2@ (@EMPH x@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 20

@DOC-VARIABLE-DEFINITIONS@
type = register\ double\ 
typeraw = register double 
@DOC-PARAMETER@
x
@DOC-PARDESC@
x within [0..1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 20

@DOC-RETURNS@
y for circle approximation within [0..1]

@DOC-DESCRIPTION@
Fast approximation of the upper left quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
@DOC-SYNOPSIS@
@STRONG gsl_approx_qcircle3@ (@EMPH x@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 20

@DOC-VARIABLE-DEFINITIONS@
type = register\ double\ 
typeraw = register double 
@DOC-PARAMETER@
x
@DOC-PARDESC@
x within [0..1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 20

@DOC-RETURNS@
y for circle approximation within [0..1]

@DOC-DESCRIPTION@
Fast approximation of the lower left quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
@DOC-SYNOPSIS@
@STRONG gsl_approx_qcircle4@ (@EMPH x@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 20

@DOC-VARIABLE-DEFINITIONS@
type = register\ double\ 
typeraw = register double 
@DOC-PARAMETER@
x
@DOC-PARDESC@
x within [0..1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 20

@DOC-RETURNS@
y for circle approximation within [0..1]

@DOC-DESCRIPTION@
Fast approximation of the lower right quadrant of a circle. Errors at x=0 and x=1 are zero, for the rest of the curve, the error wasn't minimized, but distributed to best fit the curverture of a quarter circle. The maximum error is below 0.092.  
