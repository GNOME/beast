@DOC-VARIABLE-DEFINITIONS@
name    = GSL-Functions
blurb   = GSL Function Reference
package = BEAST-0.4.0
date    = 10 Mar 2002
image   = gsl-functions

@DOC-TITLE@
GSL-Functions

@DOC-HEAD@
GSL-Functions 10 Mar 2002 BEAST-0.4.0

@DOC-NAME@
GSL-Functions - GSL Function Reference

@DOC-SYNOPSIS@
@STRONG gsl_thread_wakeup@ (@EMPH thread@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslThread*
typeraw = GslThread*
@DOC-PARAMETER@
thread
@DOC-PARDESC@
thread to wake up

@DOC-VARIABLE-DEFINITIONS@
retspace = 19


@DOC-DESCRIPTION@
Wake up a currently sleeping thread. In practice, this function simply causes the next call to @STRONG gsl_thread_sleep()@ within @EMPH thread@ to last for 0 seconds.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_abort@ (@EMPH thread@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslThread*
typeraw = GslThread*
@DOC-PARAMETER@
thread
@DOC-PARDESC@
thread to abort

@DOC-VARIABLE-DEFINITIONS@
retspace = 19


@DOC-DESCRIPTION@
Abort a currently running thread. This function does not return until the thread in question terminated execution. Note that the thread handle gets invalidated with invocation of @STRONG gsl_thread_abort()@ or @STRONG gsl_thread_queue_abort()@.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_queue_abort@ (@EMPH thread@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslThread*
typeraw = GslThread*
@DOC-PARAMETER@
thread
@DOC-PARDESC@
thread to abort

@DOC-VARIABLE-DEFINITIONS@
retspace = 19


@DOC-DESCRIPTION@
Same as @STRONG gsl_thread_abort()@, but returns as soon as possible, even if thread hasn't stopped execution yet. Note that the thread handle gets invalidated with invocation of @STRONG gsl_thread_abort()@ or @STRONG gsl_thread_queue_abort()@.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_aborted@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
@EMPH TRUE@ if the thread should abort execution

@DOC-DESCRIPTION@
Find out if the currently running thread should be aborted (the thread is supposed to return from its main thread function).  
@DOC-SYNOPSIS@
@STRONG gsl_thread_sleep@ (@EMPH max_msec@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = glong\ 
typeraw = glong 
@DOC-PARAMETER@
max_msec
@DOC-PARDESC@
maximum amount of milli seconds to sleep (-1 for infinite time)

@DOC-VARIABLE-DEFINITIONS@
retspace = 17

@DOC-RETURNS@
@EMPH TRUE@ if the thread should continue execution

@DOC-DESCRIPTION@
Sleep for the amount of time given. This function may get interrupted by wakeup or abort requests, it returns whether the thread is supposed to continue execution after waking up.  
@DOC-SYNOPSIS@
@STRONG gsl_thread_awake_after@ (@EMPH tick_stamp@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 21

@DOC-VARIABLE-DEFINITIONS@
type = guint64\ 
typeraw = guint64 
@DOC-PARAMETER@
tick_stamp
@DOC-PARDESC@
tick stamp update to trigger wakeup

@DOC-VARIABLE-DEFINITIONS@
retspace = 21


@DOC-DESCRIPTION@
Wakeup the currently running thread after the global tick stamp (see @STRONG gsl_tick_stamp()@) has been updated to @EMPH tick_stamp@. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
@DOC-SYNOPSIS@
@STRONG gsl_thread_awake_before@ (@EMPH tick_stamp@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 21

@DOC-VARIABLE-DEFINITIONS@
type = guint64\ 
typeraw = guint64 
@DOC-PARAMETER@
tick_stamp
@DOC-PARDESC@
tick stamp update to trigger wakeup

@DOC-VARIABLE-DEFINITIONS@
retspace = 21


@DOC-DESCRIPTION@
Wakeup the currently running thread upon the last global tick stamp update (see @STRONG gsl_tick_stamp()@) that happens prior to updating the global tick stamp to @EMPH tick_stamp@. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
@DOC-SYNOPSIS@
@STRONG gsl_tick_stamp@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
GSL's execution tick stamp as unsigned 64bit integer

@DOC-DESCRIPTION@
Retrive the GSL global tick stamp. GSL increments its global tick stamp at certain intervals, by specific amounts (refer to @STRONG gsl_engine_init()@ for further details). The tick stamp is a non-wrapping, unsigned 64bit integer greater than 0. Threads can schedule sleep interruptions at certain tick stamps with @STRONG gsl_thread_awake_after()@ and @STRONG gsl_thread_awake_before()@. Tick stamp updating occours at GSL engine block processing boundaries, so code that can guarantee to not run across those boundaries (for instance @STRONG GslProcessFunc()@ functions) may use the macro @EMPH GSL_TICK_STAMP@ to retrive the current tick in a faster manner (not involving mutex locking). See also @STRONG gsl_module_tick_stamp()@.  
@DOC-SYNOPSIS@
@STRONG gsl_module_tick_stamp@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
a GSL engine module

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
the module's tick stamp, indicating its process status

@DOC-DESCRIPTION@
Any thread may call this function on a valid engine module. The module specific tick stamp is updated to @STRONG gsl_tick_stamp()@ + @EMPH n_values@ every time its @STRONG GslProcessFunc()@ function was called. See also @STRONG gsl_tick_stamp()@.  
@DOC-SYNOPSIS@
@STRONG gsl_job_integrate@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
The module to integrate

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job to integrate @EMPH module@ into the engine.  
@DOC-SYNOPSIS@
@STRONG gsl_job_discard@ (@EMPH module@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 19

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
module
@DOC-PARDESC@
The module to discard

@DOC-VARIABLE-DEFINITIONS@
retspace = 19

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which remove @EMPH module@ from the engine and destroys it.  
@DOC-SYNOPSIS@
@STRONG gsl_job_connect@ (@EMPH src_module@, @EMPH src_ostream@, @EMPH dest_module@, @EMPH dest_istream@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
src_module
@DOC-PARDESC@
Module with output stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
src_ostream
@DOC-PARDESC@
Index of output stream of @EMPH src_module@

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
dest_module
@DOC-PARDESC@
Module with unconnected input stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
dest_istream
@DOC-PARDESC@
Index of input stream of @EMPH dest_module@

@DOC-VARIABLE-DEFINITIONS@
retspace = 25

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which connects the ouput stream @EMPH src_ostream@ of module @EMPH src_module@ to the input stream @EMPH dest_istream@ of module @EMPH dest_module@ (it is an error if the input stream is already connected by the time the job is executed).  
@DOC-SYNOPSIS@
@STRONG gsl_job_disconnect@ (@EMPH dest_module@, @EMPH dest_istream@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*
typeraw = GslModule*
@DOC-PARAMETER@
dest_module
@DOC-PARDESC@
Module with connected input stream

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ 
typeraw = guint     
@DOC-PARAMETER@
dest_istream
@DOC-PARDESC@
Index of input stream of @EMPH dest_module@

@DOC-VARIABLE-DEFINITIONS@
retspace = 25

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which causes the input stream @EMPH dest_istream@ of @EMPH dest_module@ to be disconnected (it is an error if the input stream isn't connected by the time the job is executed).  
@DOC-SYNOPSIS@
@STRONG GslAccessFunc@ (@EMPH module@, @EMPH data@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 9

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
module
@DOC-PARDESC@
Module to operate on

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
data
@DOC-PARDESC@
Accessor data

@DOC-VARIABLE-DEFINITIONS@
retspace = 9


@DOC-DESCRIPTION@
The GslAccessFunc is a user supplied callback function which can access a module in times it is not processing. Accessors are usually used to either read out a module's current state, or to modify its state. An accessor may only operate on the @EMPH data@ and the @EMPH module@ passed in to it.  
@DOC-SYNOPSIS@
@STRONG gsl_job_access@ (@EMPH module@, @EMPH access_func@, @EMPH data@, @EMPH free_func@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 28

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*\ \ \ \ 
typeraw = GslModule*    
@DOC-PARAMETER@
module
@DOC-PARDESC@
The module to access

@DOC-VARIABLE-DEFINITIONS@
type = GslAccessFunc\ 
typeraw = GslAccessFunc 
@DOC-PARAMETER@
access_func
@DOC-PARDESC@
The accessor function

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ \ \ 
typeraw = gpointer      
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data passed in to the accessor

@DOC-VARIABLE-DEFINITIONS@
type = GslFreeFunc\ \ \ 
typeraw = GslFreeFunc   
@DOC-PARAMETER@
free_func
@DOC-PARDESC@
Function to free @EMPH data@

@DOC-VARIABLE-DEFINITIONS@
retspace = 28

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which will invoke @EMPH access_func@ on @EMPH module@ with @EMPH data@ when the transaction queue is processed to modify the module's state.  
@DOC-SYNOPSIS@
@STRONG gsl_flow_job_access@ (@EMPH module@, @EMPH tick_stamp@, @EMPH access_func@, @EMPH data@, @EMPH free_func@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 28

@DOC-VARIABLE-DEFINITIONS@
type = GslModule*\ \ \ \ 
typeraw = GslModule*    
@DOC-PARAMETER@
module
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
type = guint64\ \ \ \ \ \ \ 
typeraw = guint64       
@DOC-PARAMETER@
tick_stamp
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
type = GslAccessFunc\ 
typeraw = GslAccessFunc 
@DOC-PARAMETER@
access_func
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ \ \ 
typeraw = gpointer      
@DOC-PARAMETER@
data
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
type = GslFreeFunc\ \ \ 
typeraw = GslFreeFunc   
@DOC-PARAMETER@
free_func
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
retspace = 28


@DOC-DESCRIPTION@

@DOC-SYNOPSIS@
@STRONG GslPollFunc@ (@EMPH data@, @EMPH n_values@, @EMPH timeout_p@, @EMPH n_fds@, @EMPH fds@, @EMPH revents_filled@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data of poll function

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Minimum number of values the engine wants to process

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
timeout_p
@DOC-PARDESC@
Location of timeout value

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_fds
@DOC-PARDESC@
Number of file descriptors used for polling

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
fds
@DOC-PARDESC@
File descriptors to be used for polling

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
revents_filled
@DOC-PARDESC@
Indicates whether @EMPH fds@ actually have their ->revents field filled with valid data.

@DOC-VARIABLE-DEFINITIONS@
retspace = 17

@DOC-RETURNS@
A boolean value indicating whether the engine should process data right now

@DOC-DESCRIPTION@
The GslPollFunc is a user supplied callback function which can be hooked into the GSL engine. The engine uses the poll functions to determine whether processing of @EMPH n_values@ in its module network is necessary. In order for the poll functions to react to extern events, such as device driver status changes, the engine will @STRONG poll(2)@ the @EMPH fds@ of the poll function and invoke the callback with @EMPH revents_filled@==@EMPH TRUE@ if any of its @EMPH fds@ changed state. The callback may also be invoked at other random times with @EMPH revents_filled@=@EMPH FALSE@. It is supposed to return @EMPH TRUE@ if network processing is currently necessary, and @EMPH FALSE@ if not. If @EMPH FALSE@ is returned, @EMPH timeout_p@ may be filled with the number of milliseconds the engine should use for polling at maximum.  
@DOC-SYNOPSIS@
@STRONG gsl_job_add_poll@ (@EMPH poll_func@, @EMPH data@, @EMPH free_func@, @EMPH n_fds@, @EMPH fds@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 28

@DOC-VARIABLE-DEFINITIONS@
type = GslPollFunc\ \ \ \ \ 
typeraw = GslPollFunc     
@DOC-PARAMETER@
poll_func
@DOC-PARDESC@
Poll function to add

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ \ \ \ \ 
typeraw = gpointer        
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data of poll function

@DOC-VARIABLE-DEFINITIONS@
type = GslFreeFunc\ \ \ \ \ 
typeraw = GslFreeFunc     
@DOC-PARAMETER@
free_func
@DOC-PARDESC@
Function to free @EMPH data@

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ \ \ \ \ 
typeraw = guint           
@DOC-PARAMETER@
n_fds
@DOC-PARDESC@
Number of poll file descriptors

@DOC-VARIABLE-DEFINITIONS@
type = const\ GslPollFD*
typeraw = const GslPollFD*
@DOC-PARAMETER@
fds
@DOC-PARDESC@
File descriptors to @STRONG select(2)@ or @STRONG poll(2)@ on

@DOC-VARIABLE-DEFINITIONS@
retspace = 28

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which adds a poll function to the engine. The poll function is used by the engine to determine whether processing is currently necessary.  
@DOC-SYNOPSIS@
@STRONG gsl_job_remove_poll@ (@EMPH poll_func@, @EMPH data@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 24

@DOC-VARIABLE-DEFINITIONS@
type = GslPollFunc\ 
typeraw = GslPollFunc 
@DOC-PARAMETER@
poll_func
@DOC-PARDESC@
Poll function to remove

@DOC-VARIABLE-DEFINITIONS@
type = gpointer\ \ \ \ 
typeraw = gpointer    
@DOC-PARAMETER@
data
@DOC-PARDESC@
Data of poll function

@DOC-VARIABLE-DEFINITIONS@
retspace = 24

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which removes a previously inserted poll function from the engine.  
@DOC-SYNOPSIS@
@STRONG gsl_job_debug@ (@EMPH debug@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 20

@DOC-VARIABLE-DEFINITIONS@
type = const\ gchar*
typeraw = const gchar*
@DOC-PARAMETER@
debug
@DOC-PARDESC@
Debug message

@DOC-VARIABLE-DEFINITIONS@
retspace = 20

@DOC-RETURNS@
New job suitable for @STRONG gsl_trans_add()@

@DOC-DESCRIPTION@
Create a new transaction job which issues @EMPH debug@ message when the job is executed. This function is meant for debugging purposes during development phase only and shouldn't be used in production code.  
@DOC-SYNOPSIS@
@STRONG gsl_trans_open@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 11

@DOC-VARIABLE-DEFINITIONS@
retspace = 11

@DOC-RETURNS@
Newly opened empty transaction

@DOC-DESCRIPTION@
Open up a new transaction to commit jobs to the GSL engine. This function may cause garbage collection (see @STRONG gsl_engine_garbage_collect()@).  
@DOC-SYNOPSIS@
@STRONG gsl_trans_add@ (@EMPH trans@, @EMPH job@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslTrans*
typeraw = GslTrans*
@DOC-PARAMETER@
trans
@DOC-PARDESC@
Opened transaction

@DOC-VARIABLE-DEFINITIONS@
type = GslJob*\ \ 
typeraw = GslJob*  
@DOC-PARAMETER@
job
@DOC-PARDESC@
Job to add

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Append a job to an opened transaction.  
@DOC-SYNOPSIS@
@STRONG gsl_trans_commit@ (@EMPH trans@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslTrans*
typeraw = GslTrans*
@DOC-PARAMETER@
trans
@DOC-PARDESC@
Opened transaction

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Close the transaction and commit it to the engine. The engine will execute the jobs contained in this transaction as soon as it has completed its current processing cycle. The jobs will be executed in the exact order they were added to the transaction.  
@DOC-SYNOPSIS@
@STRONG gsl_trans_dismiss@ (@EMPH trans@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 17

@DOC-VARIABLE-DEFINITIONS@
type = GslTrans*
typeraw = GslTrans*
@DOC-PARAMETER@
trans
@DOC-PARDESC@
Opened transaction

@DOC-VARIABLE-DEFINITIONS@
retspace = 17


@DOC-DESCRIPTION@
Close and discard the transaction, destroy all jobs currently contained in it and do not execute them. This function may cause garbage collection (see @STRONG gsl_engine_garbage_collect()@).  
@DOC-SYNOPSIS@
@STRONG gsl_transact@ (@EMPH job@, @EMPH ...@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 6

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
job
@DOC-PARDESC@
First job

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
...
@DOC-PARDESC@
@EMPH NULL@ terminated job list

@DOC-VARIABLE-DEFINITIONS@
retspace = 6


@DOC-DESCRIPTION@
Convenience function which openes up a new transaction, collects the @EMPH NULL@ terminated job list passed to the function, and commits the transaction.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_init@ (@EMPH run_threaded@, @EMPH block_size@, @EMPH sample_freq@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 24

@DOC-VARIABLE-DEFINITIONS@
type = gboolean\ 
typeraw = gboolean 
@DOC-PARAMETER@
run_threaded
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ 
typeraw = guint    
@DOC-PARAMETER@
block_size
@DOC-PARDESC@
number of values to process block wise

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ 
typeraw = guint    
@DOC-PARAMETER@
sample_freq
@DOC-PARDESC@


@DOC-VARIABLE-DEFINITIONS@
retspace = 24


@DOC-DESCRIPTION@
Initialize the GSL engine, this function must be called prior to any other engine related function and can only be invoked once. The @EMPH block_size@ determines the amount by which the global tick stamp (see @STRONG gsl_tick_stamp()@) is updated everytime the whole module network completed processing @EMPH block_size@ values.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_wait_on_trans@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
Wait until all pending transactions have been processed by the GSL Engine. This function may cause garbage collection (see @STRONG gsl_engine_garbage_collect()@).  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftac@ (@EMPH n_values@, @EMPH ri_values_in@, @EMPH ri_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 16

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_in
@DOC-PARDESC@
Complex sample values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_out
@DOC-PARDESC@
Complex frequency values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 16


@DOC-DESCRIPTION@
This function performs a decimation in time fourier transformation in forward direction, where the input values are equidistant sampled data, and the output values contain the frequency proportions of the input. The input and output arrays are complex values with real and imaginery portions interleaved, adressable in the range [0..2*n_values-1], where n_values must be a power of two. Frequencies are stored in-order, the K-th output corresponds to the frequency K/n_values. (If you want to interpret negative frequencies, note that the frequencies -K/n_values and (n_values-K)/n_values are equivalent). Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftsc@ (@EMPH n_values@, @EMPH ri_values_in@, @EMPH ri_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 16

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_in
@DOC-PARDESC@
Complex frequency values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_out
@DOC-PARDESC@
Complex sample values [0..n_values*2-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 16


@DOC-DESCRIPTION@
This function performs a decimation in time fourier transformation in backwards direction with normalization. As such, this function represents the counterpart to @STRONG gsl_power2_fftac()@, that is, a value array which is transformed into the frequency domain with @STRONG gsl_power2_fftac()@ can be reconstructed by issuing @STRONG gsl_power2_fftsc()@ on the transform. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftar@ (@EMPH n_values@, @EMPH r_values_in@, @EMPH ri_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 16

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
r_values_in
@DOC-PARDESC@
Real sample values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_out
@DOC-PARDESC@
Complex frequency values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 16


@DOC-DESCRIPTION@
Real valued variant of @STRONG gsl_power2_fftac()@, the input array contains real valued equidistant sampled data [0..n_values-1], and the output array contains the positive frequency half of the complex valued fourier transform. Note, that the complex valued fourier transform H of a purely real valued set of data, satisfies @STRONG H(-f)@ = Conj(@STRONG H(f)@), where @STRONG Conj()@ denotes the complex conjugate, so that just the positive frequency half suffices to describe the entire frequency spectrum. Even so, the resulting n_values/2 complex frequencies are one value off in storage size, but the resulting frequencies @STRONG H(0)@ and @STRONG H(n_values/2)@ are both real valued, so the real portion of @STRONG H(n_values/2)@ is stored in ri_values_out[1] (the imaginery part of @STRONG H(0)@), so that both r_values_in and ri_values_out can be of size n_values. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_power2_fftsr@ (@EMPH n_values@, @EMPH ri_values_in@, @EMPH r_values_out@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 15

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
Number of complex values

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
ri_values_in
@DOC-PARDESC@
Complex frequency values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
r_values_out
@DOC-PARDESC@
Real sample values [0..n_values-1]

@DOC-VARIABLE-DEFINITIONS@
retspace = 15


@DOC-DESCRIPTION@
Real valued variant of @STRONG gsl_power2_fftsc()@, counterpart to @STRONG gsl_power2_fftar()@, using the same frequency storage format. A real valued data set transformed into the frequency domain with @STRONG gsl_power2_fftar()@ can be reconstructed using this function. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_steepness_db@ (@EMPH iorder@, @EMPH c_freq@, @EMPH epsilon@, @EMPH stopband_db@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 27

@DOC-VARIABLE-DEFINITIONS@
type = unsigned\ int\ 
typeraw = unsigned int 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
c_freq
@DOC-PARDESC@
passband cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
stopband_db
@DOC-PARDESC@
reduction in stopband in dB (>= 0)

@DOC-VARIABLE-DEFINITIONS@
retspace = 27


@DOC-DESCRIPTION@
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on the ripple residue in the stop band.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_steepness@ (@EMPH iorder@, @EMPH c_freq@, @EMPH epsilon@, @EMPH residue@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 23

@DOC-VARIABLE-DEFINITIONS@
type = unsigned\ int\ 
typeraw = unsigned int 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
c_freq
@DOC-PARDESC@
passband cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = double\ \ \ \ \ \ \ 
typeraw = double       
@DOC-PARAMETER@
residue
@DOC-PARDESC@
maximum of transfer function in stopband (0..1)

@DOC-VARIABLE-DEFINITIONS@
retspace = 23


@DOC-DESCRIPTION@
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on ripple residue in the stop band.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_lp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at cutoff frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth lowpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_lp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at cutoff frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 lowpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_lp@ (@EMPH iorder@, @EMPH freq@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
passband cutoff frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness (c_freq * steepness < pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 lowpass filter. To gain a transition band between freq1 and freq2, pass arguements @EMPH freq@=freq1 and @EMPH steepness@=freq2/freq1. To specify the transition band width in fractions of octaves, pass @EMPH steepness@=2^octave_fraction.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_hp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
passband frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth highpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_hp@ (@EMPH iorder@, @EMPH freq@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
passband frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 highpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_hp@ (@EMPH iorder@, @EMPH freq@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
stopband frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 highpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_bp@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth bandpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_bp@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 bandpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_bp@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness factor

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 bandpass filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_butter_bs@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Butterworth bandstop filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb1_bs@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 10

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 10


@DOC-DESCRIPTION@
Tschebyscheff type 1 bandstop filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_tscheb2_bs@ (@EMPH iorder@, @EMPH freq1@, @EMPH freq2@, @EMPH steepness@, @EMPH epsilon@, @EMPH a@, @EMPH b@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 12

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
filter order (must be even)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq1
@DOC-PARDESC@
passband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq2
@DOC-PARDESC@
stopband end frequency (0..pi)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
steepness
@DOC-PARDESC@
frequency steepness factor

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
epsilon
@DOC-PARDESC@
fall off at passband frequency (0..1)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients a[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients b[0..iorder]

@DOC-VARIABLE-DEFINITIONS@
retspace = 12


@DOC-DESCRIPTION@
Tschebyscheff type 2 bandstop filter.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_fir_approx@ (@EMPH iorder@, @EMPH freq@, @EMPH value@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 9

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
iorder
@DOC-PARDESC@
order of the filter (must be oven, >= 2)

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
freq
@DOC-PARDESC@
the frequencies of the transfer function

@DOC-VARIABLE-DEFINITIONS@
type = 
typeraw = 
@DOC-PARAMETER@
value
@DOC-PARDESC@
the desired value of the transfer function

@DOC-VARIABLE-DEFINITIONS@
retspace = 9


@DOC-DESCRIPTION@
Approximates a given transfer function with an iorder-coefficient FIR filter. It is recommended to provide enough frequency values, so that @EMPH n_points@ >= @EMPH iorder@.  
@DOC-SYNOPSIS@
@STRONG gsl_filter_sine_scan@ (@EMPH order@, @EMPH a@, @EMPH b@, @EMPH freq@, @EMPH n_values@);

@DOC-VARIABLE-DEFINITIONS@
parspace = 25

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ \ \ 
typeraw = guint         
@DOC-PARAMETER@
order
@DOC-PARDESC@
order of the iir filter

@DOC-VARIABLE-DEFINITIONS@
type = const\ gdouble*
typeraw = const gdouble*
@DOC-PARAMETER@
a
@DOC-PARDESC@
root polynomial coefficients of the filter a[0..order]

@DOC-VARIABLE-DEFINITIONS@
type = const\ gdouble*
typeraw = const gdouble*
@DOC-PARAMETER@
b
@DOC-PARDESC@
pole polynomial coefficients of the filter b[0..order]

@DOC-VARIABLE-DEFINITIONS@
type = gdouble\ \ \ \ \ \ \ 
typeraw = gdouble       
@DOC-PARAMETER@
freq
@DOC-PARDESC@
frequency to test

@DOC-VARIABLE-DEFINITIONS@
type = guint\ \ \ \ \ \ \ \ \ 
typeraw = guint         
@DOC-PARAMETER@
n_values
@DOC-PARDESC@
number of samples

@DOC-VARIABLE-DEFINITIONS@
retspace = 25


@DOC-DESCRIPTION@
This function sends a sine signal of the desired frequency through an IIR filter, to test the value of the transfer function at a given point. It uses gsl_iir_filter_eval to do so.  Compared to a "mathematical approach" of finding the transfer function, this function makes it possible to see the effects of finite arithmetic during filter evaluation.  The first half of the output signal is not considered, since a lot of IIR filters have a transient phase where also overshoot is possible.  For n_values, you should specify a reasonable large value. It should be a lot larger than the filter order, and large enough to let the input signal become (close to) 1.0 multiple times.  
@DOC-SYNOPSIS@
@STRONG gsl_engine_garbage_collect@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
GSL Engine user thread function. Collects processed jobs and transactions from the engine and frees them, this involves callback invocation of @STRONG GslFreeFunc()@ functions, e.g. from @STRONG gsl_job_access()@ or @STRONG gsl_flow_job_access()@ jobs. This function may only be called from the user thread, as @STRONG GslFreeFunc()@ functions are guranteed to be executed in the user thread.  
@DOC-SYNOPSIS@
@STRONG gsl_signal_exp2@ ();

@DOC-VARIABLE-DEFINITIONS@
parspace = 3

@DOC-VARIABLE-DEFINITIONS@
retspace = 3


@DOC-DESCRIPTION@
Fast conversion of linear frequency modulation factor to exponential frequency modulation factor. This is essentially an approximation of @STRONG exp2f()@. It can be much faster than the glibc function though, by taking advantage of a limited input range and smaller precision requirements.  
