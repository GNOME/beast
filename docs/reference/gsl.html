<html>
<head>
<title>GSL (BSE-0.4.0): GSL-Functions</title>
</head>
<body text="#000000" bgcolor="#ffffff" link="#cc0000" alink="#cc0000" vlink="#990000">
<h0>GSL-Functions &nbsp &nbsp - &nbsp 05 Feb 2002 &nbsp - &nbsp GSL (BSE-0.4.0) </h0>

<h1>NAME</h1>
<blockquote>GSL-Functions - GSL Function Reference</blockquote>
<h1>SYNOPSIS</h1>
<blockquote>
<strong>gsl_thread_wakeup (</strong><u>thread</u><strong>)</strong>;
<br>
<strong>gsl_thread_abort (</strong><u>thread</u><strong>)</strong>;
<br>
<strong>gsl_thread_queue_abort (</strong><u>thread</u><strong>)</strong>;
<br>
<strong>gsl_thread_aborted (</strong><strong>)</strong>;
<br>
<strong>gsl_thread_sleep (</strong><u>max_msec</u><strong>)</strong>;
<br>
<strong>gsl_thread_awake_after (</strong><u>tick_stamp</u><strong>)</strong>;
<br>
<strong>gsl_thread_awake_before (</strong><u>tick_stamp</u><strong>)</strong>;
<br>
<strong>gsl_tick_stamp (</strong><strong>)</strong>;
<br>
<strong>gsl_module_tick_stamp (</strong><u>module</u><strong>)</strong>;
<br>
<strong>gsl_job_integrate (</strong><u>module</u><strong>)</strong>;
<br>
<strong>gsl_job_discard (</strong><u>module</u><strong>)</strong>;
<br>
<strong>gsl_job_connect (</strong><u>src_module</u>, <u>src_ostream</u>, <u>dest_module</u>, <u>dest_istream</u><strong>)</strong>;
<br>
<strong>gsl_job_disconnect (</strong><u>dest_module</u>, <u>dest_istream</u><strong>)</strong>;
<br>
<strong>GslAccessFunc (</strong><u>module</u>, <u>data</u><strong>)</strong>;
<br>
<strong>gsl_job_access (</strong><u>module</u>, <u>access_func</u>, <u>data</u>, <u>free_func</u><strong>)</strong>;
<br>
<strong>gsl_flow_job_access (</strong><u>module</u>, <u>tick_stamp</u>, <u>access_func</u>, <u>data</u>, <u>free_func</u><strong>)</strong>;
<br>
<strong>GslPollFunc (</strong><u>data</u>, <u>n_values</u>, <u>timeout_p</u>, <u>n_fds</u>, <u>fds</u>, <u>revents_filled</u><strong>)</strong>;
<br>
<strong>gsl_job_add_poll (</strong><u>poll_func</u>, <u>data</u>, <u>free_func</u>, <u>n_fds</u>, <u>fds</u><strong>)</strong>;
<br>
<strong>gsl_job_remove_poll (</strong><u>poll_func</u>, <u>data</u><strong>)</strong>;
<br>
<strong>gsl_job_debug (</strong><u>debug</u><strong>)</strong>;
<br>
<strong>gsl_trans_open (</strong><strong>)</strong>;
<br>
<strong>gsl_trans_add (</strong><u>trans</u>, <u>job</u><strong>)</strong>;
<br>
<strong>gsl_trans_commit (</strong><u>trans</u><strong>)</strong>;
<br>
<strong>gsl_trans_dismiss (</strong><u>trans</u><strong>)</strong>;
<br>
<strong>gsl_transact (</strong><u>job</u>, <u>...</u><strong>)</strong>;
<br>
<strong>gsl_engine_init (</strong><u>run_threaded</u>, <u>block_size</u>, <u>sample_freq</u><strong>)</strong>;
<br>
<strong>gsl_engine_wait_on_trans (</strong><strong>)</strong>;
<br>
<strong>gsl_power2_fftac (</strong><u>n_values</u>, <u>ri_values_in</u>, <u>ri_values_out</u><strong>)</strong>;
<br>
<strong>gsl_power2_fftsc (</strong><u>n_values</u>, <u>ri_values_in</u>, <u>ri_values_out</u><strong>)</strong>;
<br>
<strong>gsl_power2_fftar (</strong><u>n_values</u>, <u>r_values_in</u>, <u>ri_values_out</u><strong>)</strong>;
<br>
<strong>gsl_power2_fftsr (</strong><u>n_values</u>, <u>ri_values_in</u>, <u>r_values_out</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb2_steepness_db (</strong><u>iorder</u>, <u>c_freq</u>, <u>epsilon</u>, <u>stopband_db</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb2_steepness (</strong><u>iorder</u>, <u>c_freq</u>, <u>epsilon</u>, <u>residue</u><strong>)</strong>;
<br>
<strong>gsl_filter_butter_lp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb1_lp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb2_lp (</strong><u>iorder</u>, <u>freq</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_butter_hp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb1_hp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb2_hp (</strong><u>iorder</u>, <u>freq</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_butter_bp (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb1_bp (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb2_bp (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_butter_bs (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb1_bs (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_tscheb2_bs (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<br>
<strong>gsl_filter_fir_approx (</strong><u>iorder</u>, <u>freq</u>, <u>value</u><strong>)</strong>;
<br>
<strong>gsl_engine_garbage_collect (</strong><strong>)</strong>;
<br>
<strong>gsl_signal_exp2 (</strong><strong>)</strong>;
<br>
</blockquote>
<h1>DESCRIPTION</h1>
<blockquote>
<strong>gsl_thread_wakeup (</strong><u>thread</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslThread*</u><td><u>thread</u><td>thread to wake up
</table>
</blockquote>
<blockquote>
Wake up a currently sleeping thread. In practice, this function simply causes the next call to <strong>gsl_thread_sleep()</strong> within <u>thread</u> to last for 0 seconds.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_thread_abort (</strong><u>thread</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslThread*</u><td><u>thread</u><td>thread to abort
</table>
</blockquote>
<blockquote>
Abort a currently running thread. This function does not return until the thread in question terminated execution. Note that the thread handle gets invalidated with invocation of <strong>gsl_thread_abort()</strong> or <strong>gsl_thread_queue_abort()</strong>.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_thread_queue_abort (</strong><u>thread</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslThread*</u><td><u>thread</u><td>thread to abort
</table>
</blockquote>
<blockquote>
Same as <strong>gsl_thread_abort()</strong>, but returns as soon as possible, even if thread hasn't stopped execution yet. Note that the thread handle gets invalidated with invocation of <strong>gsl_thread_abort()</strong> or <strong>gsl_thread_queue_abort()</strong>.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_thread_aborted (</strong><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td colspan=2><u>RETURNS:</u><td><u>TRUE</u> if the thread should abort execution
</table>
</blockquote>
<blockquote>
Find out if the currently running thread should be aborted (the thread is supposed to return from its main thread function).  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_thread_sleep (</strong><u>max_msec</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>glong </u><td><u>max_msec</u><td>maximum amount of milli seconds to sleep (-1 for infinite time)
<tr><td colspan=2><u>RETURNS:</u><td><u>TRUE</u> if the thread should continue execution
</table>
</blockquote>
<blockquote>
Sleep for the amount of time given. This function may get interrupted by wakeup or abort requests, it returns whether the thread is supposed to continue execution after waking up.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_thread_awake_after (</strong><u>tick_stamp</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>guint64 </u><td><u>tick_stamp</u><td>tick stamp update to trigger wakeup
</table>
</blockquote>
<blockquote>
Wakeup the currently running thread after the global tick stamp (see <strong>gsl_tick_stamp()</strong>) has been updated to <u>tick_stamp</u>. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_thread_awake_before (</strong><u>tick_stamp</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>guint64 </u><td><u>tick_stamp</u><td>tick stamp update to trigger wakeup
</table>
</blockquote>
<blockquote>
Wakeup the currently running thread upon the last global tick stamp update (see <strong>gsl_tick_stamp()</strong>) that happens prior to updating the global tick stamp to <u>tick_stamp</u>. (If the moment of wakeup has already passed by, the thread is woken up at the next global tick stamp update.)  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_tick_stamp (</strong><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td colspan=2><u>RETURNS:</u><td>GSL's execution tick stamp as unsigned 64bit integer
</table>
</blockquote>
<blockquote>
Retrive the GSL global tick stamp. GSL increments its global tick stamp at certain intervals, by specific amounts (refer to <strong>gsl_engine_init()</strong> for further details). The tick stamp is a non-wrapping, unsigned 64bit integer greater than 0. Threads can schedule sleep interruptions at certain tick stamps with <strong>gsl_thread_awake_after()</strong> and <strong>gsl_thread_awake_before()</strong>. Tick stamp updating occours at GSL engine block processing boundaries, so code that can guarantee to not run across those boundaries (for instance <strong>GslProcessFunc()</strong> functions) may use the macro <u>GSL_TICK_STAMP</u> to retrive the current tick in a faster manner (not involving mutex locking). See also <strong>gsl_module_tick_stamp()</strong>.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_module_tick_stamp (</strong><u>module</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslModule*</u><td><u>module</u><td>a GSL engine module
<tr><td colspan=2><u>RETURNS:</u><td>the module's tick stamp, indicating its process status
</table>
</blockquote>
<blockquote>
Any thread may call this function on a valid engine module. The module specific tick stamp is updated to <strong>gsl_tick_stamp()</strong> + <u>n_values</u> every time its <strong>GslProcessFunc()</strong> function was called. See also <strong>gsl_tick_stamp()</strong>.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_integrate (</strong><u>module</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslModule*</u><td><u>module</u><td>The module to integrate
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job to integrate <u>module</u> into the engine.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_discard (</strong><u>module</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslModule*</u><td><u>module</u><td>The module to discard
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job which remove <u>module</u> from the engine and destroys it.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_connect (</strong><u>src_module</u>, <u>src_ostream</u>, <u>dest_module</u>, <u>dest_istream</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslModule*</u><td><u>src_module</u><td>Module with output stream
<tr><td><u>guint   </u><td><u>src_ostream</u><td>Index of output stream of <u>src_module</u>
<tr><td><u>GslModule*</u><td><u>dest_module</u><td>Module with unconnected input stream
<tr><td><u>guint   </u><td><u>dest_istream</u><td>Index of input stream of <u>dest_module</u>
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job which connects the ouput stream <u>src_ostream</u> of module <u>src_module</u> to the input stream <u>dest_istream</u> of module <u>dest_module</u> (it is an error if the input stream is already connected by the time the job is executed).  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_disconnect (</strong><u>dest_module</u>, <u>dest_istream</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslModule*</u><td><u>dest_module</u><td>Module with connected input stream
<tr><td><u>guint   </u><td><u>dest_istream</u><td>Index of input stream of <u>dest_module</u>
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job which causes the input stream <u>dest_istream</u> of <u>dest_module</u> to be disconnected (it is an error if the input stream isn't connected by the time the job is executed).  
</blockquote>
</blockquote>
<blockquote>
<strong>GslAccessFunc (</strong><u>module</u>, <u>data</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>module</u><td>Module to operate on
<tr><td><u></u><td><u>data</u><td>Accessor data
</table>
</blockquote>
<blockquote>
The GslAccessFunc is a user supplied callback function which can access a module in times it is not processing. Accessors are usually used to either read out a module's current state, or to modify its state. An accessor may only operate on the <u>data</u> and the <u>module</u> passed in to it.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_access (</strong><u>module</u>, <u>access_func</u>, <u>data</u>, <u>free_func</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslModule*</u><td><u>module</u><td>The module to access
<tr><td><u>GslAccessFunc </u><td><u>access_func</u><td>The accessor function
<tr><td><u>gpointer   </u><td><u>data</u><td>Data passed in to the accessor
<tr><td><u>GslFreeFunc  </u><td><u>free_func</u><td>Function to free <u>data</u>
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job which will invoke <u>access_func</u> on <u>module</u> with <u>data</u> when the transaction queue is processed to modify the module's state.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_flow_job_access (</strong><u>module</u>, <u>tick_stamp</u>, <u>access_func</u>, <u>data</u>, <u>free_func</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslModule*</u><td><u>module</u><td>
<tr><td><u>guint64    </u><td><u>tick_stamp</u><td>
<tr><td><u>GslAccessFunc </u><td><u>access_func</u><td>
<tr><td><u>gpointer   </u><td><u>data</u><td>
<tr><td><u>GslFreeFunc  </u><td><u>free_func</u><td>
</table>
</blockquote>
<blockquote>

</blockquote>
</blockquote>
<blockquote>
<strong>GslPollFunc (</strong><u>data</u>, <u>n_values</u>, <u>timeout_p</u>, <u>n_fds</u>, <u>fds</u>, <u>revents_filled</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>data</u><td>Data of poll function
<tr><td><u></u><td><u>n_values</u><td>Minimum number of values the engine wants to process
<tr><td><u></u><td><u>timeout_p</u><td>Location of timeout value
<tr><td><u></u><td><u>n_fds</u><td>Number of file descriptors used for polling
<tr><td><u></u><td><u>fds</u><td>File descriptors to be used for polling
<tr><td><u></u><td><u>revents_filled</u><td>Indicates whether <u>fds</u> actually have their ->revents field filled with valid data.
<tr><td colspan=2><u>RETURNS:</u><td>A boolean value indicating whether the engine should process data right now
</table>
</blockquote>
<blockquote>
The GslPollFunc is a user supplied callback function which can be hooked into the GSL engine. The engine uses the poll functions to determine whether processing of <u>n_values</u> in its module network is necessary. In order for the poll functions to react to extern events, such as device driver status changes, the engine will <strong>poll(2)</strong> the <u>fds</u> of the poll function and invoke the callback with <u>revents_filled</u>==<u>TRUE</u> if any of its <u>fds</u> changed state. The callback may also be invoked at other random times with <u>revents_filled</u>=<u>FALSE</u>. It is supposed to return <u>TRUE</u> if network processing is currently necessary, and <u>FALSE</u> if not. If <u>FALSE</u> is returned, <u>timeout_p</u> may be filled with the number of milliseconds the engine should use for polling at maximum.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_add_poll (</strong><u>poll_func</u>, <u>data</u>, <u>free_func</u>, <u>n_fds</u>, <u>fds</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslPollFunc   </u><td><u>poll_func</u><td>Poll function to add
<tr><td><u>gpointer     </u><td><u>data</u><td>Data of poll function
<tr><td><u>GslFreeFunc   </u><td><u>free_func</u><td>Function to free <u>data</u>
<tr><td><u>guint      </u><td><u>n_fds</u><td>Number of poll file descriptors
<tr><td><u>const GslPollFD*</u><td><u>fds</u><td>File descriptors to <strong>select(2)</strong> or <strong>poll(2)</strong> on
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job which adds a poll function to the engine. The poll function is used by the engine to determine whether processing is currently necessary.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_remove_poll (</strong><u>poll_func</u>, <u>data</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslPollFunc </u><td><u>poll_func</u><td>Poll function to remove
<tr><td><u>gpointer  </u><td><u>data</u><td>Data of poll function
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job which removes a previously inserted poll function from the engine.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_job_debug (</strong><u>debug</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>const gchar*</u><td><u>debug</u><td>Debug message
<tr><td colspan=2><u>RETURNS:</u><td>New job suitable for <strong>gsl_trans_add()</strong>
</table>
</blockquote>
<blockquote>
Create a new transaction job which issues <u>debug</u> message when the job is executed. This function is meant for debugging purposes during development phase only and shouldn't be used in production code.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_trans_open (</strong><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td colspan=2><u>RETURNS:</u><td>Newly opened empty transaction
</table>
</blockquote>
<blockquote>
Open up a new transaction to commit jobs to the GSL engine. This function may cause garbage collection (see <strong>gsl_engine_garbage_collect()</strong>).  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_trans_add (</strong><u>trans</u>, <u>job</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslTrans*</u><td><u>trans</u><td>Opened transaction
<tr><td><u>GslJob*</u><td><u>job</u><td>Job to add
</table>
</blockquote>
<blockquote>
Append a job to an opened transaction.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_trans_commit (</strong><u>trans</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslTrans*</u><td><u>trans</u><td>Opened transaction
</table>
</blockquote>
<blockquote>
Close the transaction and commit it to the engine. The engine will execute the jobs contained in this transaction as soon as it has completed its current processing cycle. The jobs will be executed in the exact order they were added to the transaction.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_trans_dismiss (</strong><u>trans</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>GslTrans*</u><td><u>trans</u><td>Opened transaction
</table>
</blockquote>
<blockquote>
Close and discard the transaction, destroy all jobs currently contained in it and do not execute them. This function may cause garbage collection (see <strong>gsl_engine_garbage_collect()</strong>).  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_transact (</strong><u>job</u>, <u>...</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>job</u><td>First job
<tr><td><u></u><td><u>...</u><td><u>NULL</u> terminated job list
</table>
</blockquote>
<blockquote>
Convenience function which openes up a new transaction, collects the <u>NULL</u> terminated job list passed to the function, and commits the transaction.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_engine_init (</strong><u>run_threaded</u>, <u>block_size</u>, <u>sample_freq</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>gboolean </u><td><u>run_threaded</u><td>
<tr><td><u>guint  </u><td><u>block_size</u><td>number of values to process block wise
<tr><td><u>guint  </u><td><u>sample_freq</u><td>
</table>
</blockquote>
<blockquote>
Initialize the GSL engine, this function must be called prior to any other engine related function and can only be invoked once. The <u>block_size</u> determines the amount by which the global tick stamp (see <strong>gsl_tick_stamp()</strong>) is updated everytime the whole module network completed processing <u>block_size</u> values.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_engine_wait_on_trans (</strong><strong>)</strong>;
<blockquote>
Wait until all pending transactions have been processed by the GSL Engine. This function may cause garbage collection (see <strong>gsl_engine_garbage_collect()</strong>).  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_power2_fftac (</strong><u>n_values</u>, <u>ri_values_in</u>, <u>ri_values_out</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>n_values</u><td>Number of complex values
<tr><td><u></u><td><u>ri_values_in</u><td>Complex sample values [0..n_values*2-1]
<tr><td><u></u><td><u>ri_values_out</u><td>Complex frequency values [0..n_values*2-1]
</table>
</blockquote>
<blockquote>
This function performs a decimation in time fourier transformation in forward direction, where the input values are equidistant sampled data, and the output values contain the frequency proportions of the input. The input and output arrays are complex values with real and imaginery portions interleaved, adressable in the range [0..2*n_values-1], where n_values must be a power of two. Frequencies are stored in-order, the K-th output corresponds to the frequency K/n_values. (If you want to interpret negative frequencies, note that the frequencies -K/n_values and (n_values-K)/n_values are equivalent). Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_power2_fftsc (</strong><u>n_values</u>, <u>ri_values_in</u>, <u>ri_values_out</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>n_values</u><td>Number of complex values
<tr><td><u></u><td><u>ri_values_in</u><td>Complex frequency values [0..n_values*2-1]
<tr><td><u></u><td><u>ri_values_out</u><td>Complex sample values [0..n_values*2-1]
</table>
</blockquote>
<blockquote>
This function performs a decimation in time fourier transformation in backwards direction with normalization. As such, this function represents the counterpart to <strong>gsl_power2_fftac()</strong>, that is, a value array which is transformed into the frequency domain with <strong>gsl_power2_fftac()</strong> can be reconstructed by issuing <strong>gsl_power2_fftsc()</strong> on the transform. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_power2_fftar (</strong><u>n_values</u>, <u>r_values_in</u>, <u>ri_values_out</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>n_values</u><td>Number of complex values
<tr><td><u></u><td><u>r_values_in</u><td>Real sample values [0..n_values-1]
<tr><td><u></u><td><u>ri_values_out</u><td>Complex frequency values [0..n_values-1]
</table>
</blockquote>
<blockquote>
Real valued variant of <strong>gsl_power2_fftac()</strong>, the input array contains real valued equidistant sampled data [0..n_values-1], and the output array contains the positive frequency half of the complex valued fourier transform. Note, that the complex valued fourier transform H of a purely real valued set of data, satisfies <strong>H(-f)</strong> = Conj(<strong>H(f)</strong>), where <strong>Conj()</strong> denotes the complex conjugate, so that just the positive frequency half suffices to describe the entire frequency spectrum. Even so, the resulting n_values/2 complex frequencies are one value off in storage size, but the resulting frequencies <strong>H(0)</strong> and <strong>H(n_values/2)</strong> are both real valued, so the real portion of <strong>H(n_values/2)</strong> is stored in ri_values_out[1] (the imaginery part of <strong>H(0)</strong>), so that both r_values_in and ri_values_out can be of size n_values. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_power2_fftsr (</strong><u>n_values</u>, <u>ri_values_in</u>, <u>r_values_out</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>n_values</u><td>Number of complex values
<tr><td><u></u><td><u>ri_values_in</u><td>Complex frequency values [0..n_values-1]
<tr><td><u></u><td><u>r_values_out</u><td>Real sample values [0..n_values-1]
</table>
</blockquote>
<blockquote>
Real valued variant of <strong>gsl_power2_fftsc()</strong>, counterpart to <strong>gsl_power2_fftar()</strong>, using the same frequency storage format. A real valued data set transformed into the frequency domain with <strong>gsl_power2_fftar()</strong> can be reconstructed using this function. Note that the transformation is performed out of place, the input array is not modified, and may not overlap with the output array.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb2_steepness_db (</strong><u>iorder</u>, <u>c_freq</u>, <u>epsilon</u>, <u>stopband_db</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>unsigned int </u><td><u>iorder</u><td>filter order
<tr><td><u>double    </u><td><u>c_freq</u><td>passband cutoff frequency (0..pi)
<tr><td><u>double    </u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u>double    </u><td><u>stopband_db</u><td>reduction in stopband in dB (>= 0)
</table>
</blockquote>
<blockquote>
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on the ripple residue in the stop band.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb2_steepness (</strong><u>iorder</u>, <u>c_freq</u>, <u>epsilon</u>, <u>residue</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u>unsigned int </u><td><u>iorder</u><td>filter order
<tr><td><u>double    </u><td><u>c_freq</u><td>passband cutoff frequency (0..pi)
<tr><td><u>double    </u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u>double    </u><td><u>residue</u><td>maximum of transfer function in stopband (0..1)
</table>
</blockquote>
<blockquote>
Calculates the steepness parameter for Tschebyscheff type 2 lowpass filter, based on ripple residue in the stop band.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_butter_lp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order
<tr><td><u></u><td><u>freq</u><td>cutoff frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at cutoff frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Butterworth lowpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb1_lp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order
<tr><td><u></u><td><u>freq</u><td>cutoff frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at cutoff frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 1 lowpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb2_lp (</strong><u>iorder</u>, <u>freq</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order
<tr><td><u></u><td><u>freq</u><td>passband cutoff frequency (0..pi)
<tr><td><u></u><td><u>steepness</u><td>frequency steepness (c_freq * steepness < pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 2 lowpass filter. To gain a transition band between freq1 and freq2, pass arguements <u>freq</u>=freq1 and <u>steepness</u>=freq2/freq1. To specify the transition band width in fractions of octaves, pass <u>steepness</u>=2^octave_fraction.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_butter_hp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order
<tr><td><u></u><td><u>freq</u><td>passband frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Butterworth highpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb1_hp (</strong><u>iorder</u>, <u>freq</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order
<tr><td><u></u><td><u>freq</u><td>passband frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 1 highpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb2_hp (</strong><u>iorder</u>, <u>freq</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order
<tr><td><u></u><td><u>freq</u><td>stopband frequency (0..pi)
<tr><td><u></u><td><u>steepness</u><td>frequency steepness
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 2 highpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_butter_bp (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order (must be even)
<tr><td><u></u><td><u>freq1</u><td>stopband end frequency (0..pi)
<tr><td><u></u><td><u>freq2</u><td>passband end frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Butterworth bandpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb1_bp (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order (must be even)
<tr><td><u></u><td><u>freq1</u><td>stopband end frequency (0..pi)
<tr><td><u></u><td><u>freq2</u><td>passband end frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 1 bandpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb2_bp (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order (must be even)
<tr><td><u></u><td><u>freq1</u><td>stopband end frequency (0..pi)
<tr><td><u></u><td><u>freq2</u><td>passband end frequency (0..pi)
<tr><td><u></u><td><u>steepness</u><td>frequency steepness factor
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 2 bandpass filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_butter_bs (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order (must be even)
<tr><td><u></u><td><u>freq1</u><td>passband end frequency (0..pi)
<tr><td><u></u><td><u>freq2</u><td>stopband end frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Butterworth bandstop filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb1_bs (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order (must be even)
<tr><td><u></u><td><u>freq1</u><td>passband end frequency (0..pi)
<tr><td><u></u><td><u>freq2</u><td>stopband end frequency (0..pi)
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 1 bandstop filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_tscheb2_bs (</strong><u>iorder</u>, <u>freq1</u>, <u>freq2</u>, <u>steepness</u>, <u>epsilon</u>, <u>a</u>, <u>b</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>filter order (must be even)
<tr><td><u></u><td><u>freq1</u><td>passband end frequency (0..pi)
<tr><td><u></u><td><u>freq2</u><td>stopband end frequency (0..pi)
<tr><td><u></u><td><u>steepness</u><td>frequency steepness factor
<tr><td><u></u><td><u>epsilon</u><td>fall off at passband frequency (0..1)
<tr><td><u></u><td><u>a</u><td>root polynomial coefficients a[0..iorder]
<tr><td><u></u><td><u>b</u><td>pole polynomial coefficients b[0..iorder]
</table>
</blockquote>
<blockquote>
Tschebyscheff type 2 bandstop filter.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_filter_fir_approx (</strong><u>iorder</u>, <u>freq</u>, <u>value</u><strong>)</strong>;
<blockquote>
<table border=0 summary=" ">
<tr><td><u></u><td><u>iorder</u><td>order of the filter (must be odd, >= 3)
<tr><td><u></u><td><u>freq</u><td>the frequencies of the transfer function
<tr><td><u></u><td><u>value</u><td>the desired value of the transfer function
</table>
</blockquote>
<blockquote>
Approximates a given transfer function with an iorder-coefficient FIR filter. It is recommended to provide enough frequency values, so that <u>n_points</u> >= <u>iorder</u>.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_engine_garbage_collect (</strong><strong>)</strong>;
<blockquote>
GSL Engine user thread function. Collects processed jobs and transactions from the engine and frees them, this involves callback invocation of <strong>GslFreeFunc()</strong> functions, e.g. from <strong>gsl_job_access()</strong> or <strong>gsl_flow_job_access()</strong> jobs. This function may only be called from the user thread, as <strong>GslFreeFunc()</strong> functions are guranteed to be executed in the user thread.  
</blockquote>
</blockquote>
<blockquote>
<strong>gsl_signal_exp2 (</strong><strong>)</strong>;
<blockquote>
Fast conversion of linear frequency modulation factor to exponential frequency modulation factor. This is essentially an approximation of <strong>exp2f()</strong>. It can be much faster than the glibc function though, by taking advantage of a limited input range and smaller precision requirements.  
</blockquote>
</blockquote>

</body>
</html>
