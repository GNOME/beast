\input texinfo   @c emacs: -*-texinfo-*-
@c %**start of header
@settitle SFIDL Documentation
@footnotestyle end
@c %**end of header

@include texiutils.texi

@doctitle SFIDL Documentation
@docauthor Stefan Westerfeld

@node Top,,,
@center @revision{Document revised:}

This document gives an overview over SFIDL, which is used
in @beast{} for two purposes:

@enumerate
@item Describe the API in a language independant fashion, to make
  it possible to access the @bse functionality from C, C++, Scheme
  (and possibly other languages).
@item Provide an easy way to fully specify the API of modules, @c FIXME: link
  specifying all necessary information to generate a useful GUI
  automatically.
@end enumerate  
  

@contents

@chapter What is SFI?

@c FIXME(Tim):
@c 1 - What is SFI?:
@c der absatz erklaert eigentlich nicht, dass es
@c einen unterschied zwischen sfidl und sfi giebt, das eine ist der
@c idl compiler, das andere ist eine unterstuetzungs library, die
@c das glue layder implementiert.

@section Overview

To provide an API to more than one programming language, we first specify
the API in a @emph{language independant} fashion. Therefore, we use an .idl
file, which contains a description what a class or procedure looks like.

Then, it is possible to provide an implementation in C or C++.

Finally, for different languages, code to access that implementation can
be generated automatically.

@section Design goals

We tried to accomplish a number of different design goals during the SFI
design.

@enumerate
@item SFI should act as strict isolation between the (realtime) @bse
  core, containing the implementation, and the user. The core should
  run either in a seperate thread, or in a seperate process.
@item Adding functionality to the implementation (such as new methods,
  new classes, new procedures, new procedure parameters, new record fields)
  should generally not affect a client's ability to talk to the core.
  That is, updating the core to a newer version should not force
  recompiles.
@item Access to the @bse code should be possible from various programming
  languages.
@item Writing plugins should be @emph{as easy as possible}.
@end enumerate

@chapter The .idl files

@section The basics: comments and namespaces.

The syntax of .idl files is similar to C++ and/or CORBA IDL. In the following
sections the elements will be described. First of all, you need to know that
everything needs to be declared within the scope of a namespace. This avoids
collisions.

The syntax for namespace is

@example
// IDL Code

namespace Foo @{
  ... declarations go here ...
  sequence @{  /* example sequence of integer values */
    Sfi::Int ints;
  @} IntSeq;
  ... more declarations go here ...
@}

@end example

Namespaces can not be nested. There is an additional using keyword, which
can be used to use avoid using the "::" which says that we used something
from a different namespace:

@example
// IDL Code

namespace Bar @{
  ... declarations go here ...
  Foo::IntSeq getEvenNumbers (Sfi::Int bound);	// need to namespace Foo::
  using namespace Foo;				// add Foo:: to namespace search list
  IntSeq getPrimeNumbers (Sfi::Int bound);	// IntSeq is found in Foo:: automatically
  ... more declarations go here ...
@}

@end example

As you see, primitive types (like Int) are declared within the Sfi namespace. C
and C++ style comments work as usually.

@section Data types: primitive and composite.

@subsection Simple primitive types

SFI provides a number of predefined primitive data types. These are

@itemize
@item @strong{@emph{void}}
@* no value (this is only used for return values of procedures/methods which have no return value)
@item @strong{@emph{Sfi::Bool}}
@* a boolean value, which can be either @emph{true} or @emph{false}
@item @strong{@emph{Sfi::Int}}
@* a 32bit signed integer
@item @strong{@emph{Sfi::Num}}
@* a 64bit signed integer
@item @strong{@emph{Sfi::Real}}
@* a 64bit double floating point value
@item @strong{@emph{Sfi::String}}
@* a character string
@item @strong{@emph{Sfi::BBlock}}
@* a block of bytes (optimized for bulk data transfer)
@item @strong{@emph{Sfi::FBlock}}
@* a block of 32bit floating point values (optimized for bulk data transfer)
@item @strong{@emph{Sfi::Rec}}
@* a special type, which can hold any record (for records see @uref{beast-doc://sfidl-manual#composite-types,,below})
@end itemize

@subsection Choices

In addition to these simple primitive types, it is possible to define a choice
as follows:

@example
// IDL Code

namespace Foo @{
  choice WaveForm @{
    WAVE_FORM_SINE,
    WAVE_FORM_SAW,
    WAVE_FORM_RECT
  @};
@}
@end example

This means that WaveForm is one of these choices. You can add two informations
to each choice value (both optional):

@itemize
@item The number that will be used in the implementation (where in C and C++ the
  choice will appear as enum).
@item A user readable string, which can be used in the GUI to describe the value
  of the choice to the user (this string also can be translated). @c FIXME: but won't be currently
@end itemize

@example
// IDL Code

namespace Foo @{
  choice WaveForm @{
    WAVE_FORM_NONE = (Neutral, "No waveform"),
    WAVE_FORM_SINE = (1,       "Sine wave"),
    WAVE_FORM_SAW  = (2,       "Sawtooth wave"),
    WAVE_FORM_RECT = (3,       "Rectangle wave")
  @};
@}
@end example

There is no guarantee what number the interfacing code using the choice in C and C++
will see for a particular WaveForm (i.e. WAVE_FORM_SINE could be 3 in client code).
This makes it possible to add choice values or change their number even after
the client got compiled. (Internally the communication is done by passing the
choice value as string).

There is one exception: the Neutral keyword indicates that the number should be 0
for both, client code and implementation. In C/C++, this allows writing

@example
@{
// C++ Code

  Foo::WaveForm wave = osc->getWaveForm();
  if (!wave)
    printf ("No wave form selected.\n");
@}
@end example

@anchor{composite-types}
@subsection Composite types

More complex data types can be constructed from these simple data types. There are two composite
types: records and sequences.

Sequences are used for a sequence of multiple values of the same data type. The syntax is:

@example
// IDL Code

namespace Foo @{
  sequence IntSeq @{
    Sfi::Int ints;  // the contained type
  @};
@}
@end example

A sequence may then hold 0, 1 or N values of the same type. The name "ints" here is only used for
the C language, where the ints contains the actual data and n_ints contains the number of items
in the sequence.

@example
// C Code

  FooIntSeq *seq = foo_int_seq_new();
  foo_int_seq_resize (seq, 2);
  seq->ints[0] = seq->ints[1] = 42;
  g_assert (seq->n_ints == 2)
@end example

Records can be used for a sequence of values of different data types (they behave similar
to structs in C/C++).

@example
// IDL Code

namespace Foo @{
  using namespace Sfi;

  record PartNote @{
    // a human readable string describing what the record does (optional)
    Info     blurb = "Part specific note representation";

    // the record fields
    Int      id;
    Int      tick;
    Int      duration;
    Int      note;
    Int      fine_tune;
    Real     velocity;
    Bool     selected;
  @};
@}
@end example

In opposition to sequences, NULL (or nil or whatever is adequate for the language you are
using) is a possible value for records, that is, a record value either contains all of
the above fields, or it is a NULL pointer.

For sequences, NULL is not a valid value (you can always use empty sequences there).

@emph{Parameter specifications:} Note that you can, and probably should add parameter
specifications for the fields in a sequence and a record. However, we describe parameter
specifications seperately below. @c FIXME: link!

@subsection Prototyping

In some cases you know that a certain type will be defined later, but you can't give it's
definition already. Perhaps this occurs because two types, often classes, need each other
in their definition. Perhaps this also occurs because you want seperate things in seperate
.idl files in a special way.

You can use prototypes in this case, for all types the IDL compile understands.

@example
namespace Foo @{
  choice SomeChoice;
  sequence SomeSequence;
  record SomeRecord;
  class SomeClass;

  record Test @{
    SomeChoice   a;
    SomeSequence b;
    SomeRecord   c;
    SomeClass    d;
  @};
@}
@end example

@section Classes and procedures

@subsection Classes

IDL defined APIs consist mostly of classes. SFI supports single inheritance, so a set
of simple classes might look like this (not taken from the @bse class hierarchy):

@example
// IDL Code

namespace Foo @{
  using namespace Sfi;

  class AudioObject @{
    void play ();
    void stop ();
  @};

  class Sample : AudioObject @{
  @};

  class Song : AudioObject @{
    Sample loadSample (String filename);
    void insertSample (Sample sample, Real position, Real speed);
  @};
@}
@end example

As far as this example goes, we have only added the bare minimum. It is however
possible (and probably desirable) to add defaults and documentation to the methods,
as demonstrated in this simple example:

@example
// IDL Code

#include <bse/bse.idl>

namespace Foo @{
  using namespace Bse; // for Bse::STANDARD
  // ... as above ...

  class Song : AudioObject @{
    Sample loadSample (Sample filename) @{
      Info blurb = _("This loads a sample for further use into the song");  // the _ function marks this string for translation

      In  filename = (_("Sample Filename"), _("The name of the sample file"), "", STANDARD);
      Out sample   = (_("Sample"), _("The newly loaded sample"), STANDARD);
    @};
    // ... as above ...
  @};
@}
@end example

Return and argument values referring to instances of classes (in this example samples)
can be NULL. So loadSample in this example would probably return a valid sample, if
the sample file could be loaded successfully, and NULL otherwise.

We say something about the valid ranges, name,... of filename and sample by assigning
a parameter specification here. More about parameter specifications can be found in the
section PARAM SPECS. @c FIXME: link

@subsection Signals

Signals provide the possibility for objects (instances of classes) to emit events.
A user can connect to the signal, and whenever a signal gets emitted, his callback
gets called. In our example it would be possible to add two signals to AudioObject, one
where it emits the current position regularily while playing, and one that gets emitted
when it is done playing.

@example
// IDL Code

namespace Foo @{
  class AudioObject @{
    void play ();
    void stop ();

    signal positionChanged (Real new_position);
    signal donePlaying ();
  @};
@}
@end example

@subsection Properties

Another important element commonly found in classes are properties. They can be grouped together
for better readability in the GUI.

@example
// IDL Code

#include <bse/bse.idl>

class Balance : Bse::Effect @{
  // ...
  group _("Audio Input") @{
    Real  alevel1    = Perc (_("Input 1 [%]"), _("Attenuate the level of audio input 1"), 100, STANDARD);
    Real  alevel2    = Perc (_("Input 2 [%]"), _("Attenuate the level of audio input 2"), 100, STANDARD);
    Real  abalance   = Balance (_("Balance"), _("Balance audio input levels"), 0, GUI);
  @};
  group _("Control Input") @{
    Real  clevel1    = Perc (_("Input 1 [%]"), _("Attenuate the level of control input 1"), 100, STANDARD);
    Real  clevel2    = Perc (_("Input 2 [%]"), _("Attenuate the level of control input 2"), 100, STANDARD);
    Real  cbalance   = Balance (_("Balance"), _("Balance control input levels"), 0, GUI);
  @};
  group _("Output Panning") @{
    Real  ostrength  = Perc (_("Control Strength"), _("Adjust how much the control signals affect the output balance"), 100, STANDARD);
    Real  lowpass    = Frequency (_("Lowpass [Hz]"), _("Lowpass filter frequency for the control signal"), 100, 100, 1000, STANDARD);
    Real  obalance   = Balance (_("Output Balance"), _("Adjust output balance between left and right"), 0, STANDARD);
  @};
@};
@end example

As you see the properties can be of any IDL type.

We say something about the valid ranges, name,... of the properties we define by assigning
a parameter specification here. More about parameter specifications can be found in the
section PARAM SPECS. @c FIXME: link

For this section, it is only useful to know that the last element of the parameter specification
adds some flags. For instance STANDARD means that the property can be read, written, will be saved
to the file and shown in the gui. GUI on the contrary means that the property will only be shown
in the gui, can be changed by the GUI, but won't be saved to the file.

@subsection Streams

For classes that do audio processing (module objects), it is necessary to specify streams,
which will transport the audio data into the module, and the resulting audio data out of it.
Generally there are three types of streams:

@itemize
@item @emph{IStream}s contain input audio signal for the module
@item @emph{OStream}s contain output audio signal from the module
@item @emph{JStream}s contain 0, 1 or more input audio signals to the module
@end itemize

@example
namespace Arts @{
class Compressor : Bse::Effect @{
  // ...
  IStream invalue   = (_("Audio In"), _("Audio input"));
  OStream outvalue  = (_("Audio Out"), _("Compressed audio output"));
@};
@}
@end example

As you see, the syntax is quite straight forward, containing a variable name
and the specification of the translatable user visible strings, which contain
the name of the stream, and a blurb describing what it does.

@subsection Procedures

Procedures can be thought of as methods-without-a-class. A classic example is:

@example
namespace Bse @{
  Real note_to_freq (Int note, Int fine_tune);
@}
@end example

which converts a midi note to a frequency, using a given fine tune. The same
syntactic elements for specifying more details (parameter speccifications,
Info strings) that are valid for methods can be used here as well.

@chapter The sfidl command line utility

@chapter The language bindings

@bye
