BseHeart
========

Bse's heart is a unique globally existing object of type BseHeart which
takes care of glueing the PCM devices and the internal network structure
together and handle syncronization issues.
BseHeart brings the internal network to work by incrementing a global
BSE index variable, cycling all active BseSources to that new index,
collecting their output chunks and writing them into the output PCM devices.
As of now there are still some unsolved syncronization problems, such
as having multiple PCM devices that run at different speeds. While this
could be solved for multiples/fractions of their mixing frequencies,
such as one device (card) running at 44100Hz and another one at 22050Hz,
problems still remain for slight alterations in their oscilaltors if
a device e.g. runs at 44099Hz (such as the es1371 from newer PCI SB
cards).
For the time being, we do not handle different output/input frequencies
at all and use our own syncronization within BSE, which is closely tied
to GLib's main loop mechanism with BseHeart interacting with it by attaching
a GSource.

To support user defined latencies, PCM Devices implement their own output
buffer queue which is used for temporary storage of output buffers if
the specified latency forces a delay greater than what can be achived through
the device driver's queue. The devices also maintain an input queue for
recorded data to avoid overruns in the PCM drivers, ideally these queues
will immediatedly be cleared again because output is also required.
FIXME: A check may be necessary to catch indefinitely growing input
queues due to input->output frequency inconsistencies. We will also
need to catch input underruns here, though handling that is somwhat
easier in that we can simply slide in a zero pad chunk there.

To support user defined latencies, BseHeart processes data as follows:
 - prepare():
	We walk all output (and input) devices until one is found that reports
	requirement to be dispatched. If none is found the devices report
	an estimated timeout value for when they will probably need to
	be dispatched. The minimum timeout value is reported to GLib's
	main loop.
- check():
	We simply do the same thing as in prepare() to figure whether
	some PCM devices need dispatching (no need for a timeout value though).
- dispatch():
	We walk the input devices so they can queue up incoming data.
	We walk the output devices so they can write out their queue contents,
	they also report whether they need a new input block according to the
	latency setting.
	Now here's the tweak, if *any* output device reports the need for
	further input data, we increment the BseIndex of all currently
	active BseSources, calc their output chunks and queue them up for
	all output sources connected to them.

[as of currently (24.12.1999), the described model is actually in the
 process of being implemented]
