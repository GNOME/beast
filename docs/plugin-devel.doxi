@doxer_dnl      # emacs: -*- mode: texinfo; texinfo-open-quote: "\""; texinfo-close-quote: "\""; -*-
@doxer_set{rvstamp,parse_date} $Date: 2006/02/21 00:28:59 $
@include @doxer_get{DOXI_INCLUDE_FILE}
@doxer_set{title}	BEAST/BSE - Plugin Development

@titlesection
@doctitle		@bse Plugin Development
@*
@docauthor              Tim Janik
@*
@center 		Document revised: @doxer_get{rvstamp}
@*

In this document, the basic concepts necessary for @bse plugin development
are established, and an example plugin is being developed.

@tocsection Table of Contents

@section Getting Started

You don't need a full fledged software development environment in order
build a @bse plugin, a proper @beast installation, your favourite text editor
and a recent version of
@uri{http://gcc.gnu.org/, GCC}
will do fine on the technical side.
Writing a synthesis plugin also requires at least some basic knowledge
about digital audio mathematics (digital signal processing) and for @bse
also a reasonably good idea of OO and C++. If you are new to digital
audio processing in general you can find
a link list to tutorials and DSP programming tips at the @beast
@uri{http://beast.gtk.org/, Website}. A good foundation in maths
helps a lot in understanding the materiels covered.


@section Basic Concepts

The most central element realised in @bse for the creation and modification
of audio signals is the "Module". A module almost always has one or
more output signals and may have any amount of input signals.
In addition, modules can define a variety of "Properties" which
represent settings used to alter behaviour of a module.

@center @image{images/module-voices.png, Module and Voices}

@bse supports multiple dynamically allocated voices internally which are
represented by a single object in GUIs like the one provided by @beast{}.
For this reason, a distinction is made in module implementations between
the "Module Object" corresponding to the object displayed at the GUI,
and the "Engine Modules" of which there may be many per module object,
used for audio processing within the dynamic voices.
Properties and channels are registered with the module object class and
individual property changes are sent to the module object. The module
object then passes on property changes to the engine modules, taking
care of syncronization issues which arise because engine modules live
and process audio data in seperate threads.

To summarize, in order to write a @bse module, we need to:
@itemize
@item define the module object
@item add properties to the module object
@item add input and output channels to the module object
@item define an engine module in the module object
@item implement the data processing function of the engine module.
@done


@section Defining the module

In the past, the @bse plugin API went through quite a few major rewrites
to make plugin implementations as easy as possible. At this point,
a standard module needs three files for a full implementation:

@enumerate
@item an @file{.idl} file containing class, property and channel definitions
@item a @file{.cc} file containing the data processing and property
      handling logic
@item an icon, 64 by 64 pixels RGBA format, saved as @file{.png} file.
@done


@subsection Writing the @file{IDL} file

@bse provides an IDL compiler for object definitions to eliminate any
mechanic code fragments the programmer would need to create manually
otherwise and to generate binding and glue code between various
@bse components, the IDL compiler is described in detail in
the @uri{sfidl-manual.html, sfidl manual}.

To make use of the BSE object tree, every plugin IDL file starts out with
an include statement. Then a namespace is opened within which the desired
classes, structures or choices (a type of enumeration) can be defined.

For most plugins, an ordinary class definition with properties and input
and output channels suffices:

@example
#include <bse/bse.idl>                  // include BSE classes and definitions
namespace Bse { namespace Contrib {     // enter the namespace Bse::Contrib
class NotchFilter : Effect {            // derive Notchfilter from Bse::Effect
  Real    frequency;                    // a property
  OStream audio_out;                    // output signal
};
} } // Bse::Contrib
@done

Here we have a small @object{NotchFilter} object, defined in the namespace
@ident{Bse::Contrib} which is the standard namespace for third-party
@bse plugins, more on namespaces can be found in the
@uri{sfidl-manual.html#namespaces, sfidl Namespaces}.
The object has a @prop{frequency} property of type @type{Real} and
an output channel @channel{audio_out}.

@anchor{channels}
@subsection Input and output channels

In order for a module to effectively process audio, it needs input and output
signal channels, unless its purely a producer for which signal inputs would
be useless. Often a module needs "audio" channels and "control" channels,
that is, some channels are used for audible signals, and other are used for
non-audible control signals, such as volume. It is not entirely clear for
every signal whether it is an audio or a control signal. Often it is its use
that would best suit to provide a classification into either category but
advanced knowledge of all possible uses is not available to the ordinary
plugin writer.
To fully support every kind of signal use, @bse doesn't make a technical
distinction between so decided "audio" and "control" signals.

It is recommended however, that in order to improve usability, signals
envisioned to be used primarily as audio signals are placed before
other signals envisioned to be used as control signals in a class
definition and therefore in generated GUIs. A good example for a module
meeting this requirement is the @type{BseAmplifier}:
@example
class Amplifier : Effect {
  IStream audio_in1  = (_("Audio In1"), _("First audio input"));
  IStream audio_in2  = (_("Audio In2"), _("Second audio input"));
  IStream ctrl_in1   = (_("Ctrl In1"), _("First control input"));
  IStream ctrl_in2   = (_("Ctrl In2"), _("Second control input"));
  OStream audio_out  = (_("Audio Out"), _("Amplified audio output"));
};
@done
For classes such as @option{mix1} or @option{mix2} which indicate
multi channel mixer effects (see
@uri{plugin-devel.html#class-options, class options}), the audio
channels put to actual use are also the first channels provided by a module.

A @bse module may have three different types of channels:
@enumerate
@item @type{IStream} - an input stream, to be connected to a single output.
@item @type{JStream} - an input stream, to be connected to many outputs (to join).
@item @type{OStream} - an output stream, may be connected to any number of input streams.
@done


@anchor{properties}
@subsection Property types

@bse provides a large set of property constructors.
By convention, all constructors expect a translatable label as first
argument, a translatable description as second argument and an option
string as last argument, as described in the
@uri{sfidl-manual.html#properties, sfidl Properties}.
The various supported options are described in the next section. Here, we give an
overview of the various constructors provided by @bse{}, grouped by types.
Note that some property constructors already add extra options to the arguments given,
for instance @func{Trigger()} will automatically provide the options @option{trigger}
and @option{skip-undo}.

@subsubsection Bool properties
@itemize
@item @strong{@func{Bool} (@var{label}, @var{description}, @var{default}, @var{options})} @*
        An ordinary property of type @type{Bool}. For GUIs and documentation generation, the
        translatable strings @var{label} and @var{description} are provided. The default
        value is given by @var{default}. Possible values (e.g. @option{trigger} which
	might be handy for some booleans) for @var{options} are discussed in the
	@uri{plugin-devel.html#options, property options section}.
@item @strong{@func{Trigger} (@var{label}, @var{description}, @var{options})} @*
	This is a boolean property that's practically always @const{FALSE}. It may be
	set to @const{TRUE} in a trigger attempt though, so certain actions may be
	started in response. GUIs would usually display this option via a clickable
	button. All plugin's set_property() methods automatically reset trigger
        property values to @const{FALSE} after invoking the property_changed() method.
@done


@subsubsection Real (IEEE-754 double precision floating point) properties
@itemize
@item @strong{@func{Real}      (@var{label}, @var{description}, @var{default}, @var{minimum}, @var{maximum}, @var{stepping}, @var{options})} @*
        An ordinary property of type @type{Real}. For GUIs and documentation generation, the
	translatable strings @var{label} and @var{description} are provided. The default,
	minimum and maximum values for the @type{Real} property are given by the respective arguments.
	The @var{stepping} argument can be used by GUIs to provide increment/decrement
	editing abilities. Possible values for @var{options} are discussed in the
	@uri{plugin-devel.html#options, property options section}.
@item @strong{@func{Perc}      (@var{label}, @var{description}, @var{default}, @var{options})} @*
        Percentage property, the minimum and maximum are fixed 0 and 100 respectively, and additional options
        are provided for GUIs to recognize percentage properties as such.
@item @strong{@func{DBVolume}  (@var{label}, @var{description}, @var{default_db}, @var{minimum_db}, @var{maximum_db}, @var{options})} @* 
	A @type{DBVolume} property is used for @type{Real}-valued properties with values >0 which are used as volume factors and
	should be displayed and editable as values in decibel.
	The @var{default_db}, @var{minimum_db} and @var{maximum_db} parameters are converted into linear volume factors
	before being interpreted as property default and limits. For example, a @code{DBVolume("", "", 0, -6, +6, STANDARD)}
	property will actually default to 1.0 (0 decibel) and hold values in the range +0.501 (-6 decibel) .. +1.995 (+6 decibel).
@item @strong{@func{Balance}   (@var{label}, @var{description}, @var{default}, @var{options})} @* 
	A @type{Balance} property is similar to a normal @type{Real} property, but has a fixed
	minimum and maximum of -100 and +100 and defaults to 0.
@item @strong{@func{Gain}      (@var{label}, @var{description}, @var{default}, @var{minimum}, @var{maximum}, @var{stepping}, @var{options})} @*
@item @strong{@func{Freq}      (@var{label}, @var{description}, @var{default}, @var{options})} @*
        A @type{Real} property with logarithmic scale centered around A+2.
	The actual range of this property in Hertz goes from 0.00005=1/20000Hz to 20000Hz.
@item @strong{@func{Frequency} (@var{label}, @var{description}, @var{default}, @var{minimum}, @var{maximum}, @var{options})} @*
        A @type{Real} property with logarithmic scale centered around A+2, setup with a @var{stepping} of 10.
        In order for the logarithmic scale to fit the parameter ranges, the @var{minimum} frequency 
        must be smaller than 51.9Hz (corresponds to As-1) and the @var{maximum} frequency must be larger than 15053Hz (corresponds to Ais+6).
@item @strong{@func{LogScale}  (@var{label}, @var{description}, @var{default}, @var{minimum}, @var{maximum}, @var{stepping}, @var{center}, @var{base}, @var{n_steps}, @var{options})} @*
        Properties of this type can be displayed by using a logarithmic scale.
        The arguments @var{base} and @var{n_steps} determine the logarithmic scale which starts
        from @code{center*base^(-n_steps)} and reaches up to @code{center*base^(+n_steps)}
        with @code{center*base^(0) = center} in the middle. For example, a six octave scale with
        @code{center=440}, @code{base=2} and @code{n_steps=3} would look like this:

@example
Minimum:      440 * 2^-3 = 440 * 0.125 =   55 (A-2)
Intermediate: 440 * 2^-2 = 440 * 0.25  =  110 (A-1)
Intermediate: 440 * 2^-1 = 440 * 0.5   =  220 (A)
Center:       440 * 2^0  = 440 * 1     =  440 (A+1)
Intermediate: 440 * 2^1  = 440 * 2     =  880 (A+2)
Intermediate: 440 * 2^2  = 440 * 4     = 1760 (A+3)
Maximum:      440 * 2^3  = 440 * 8     = 3520 (A+4)
@done
@done


@subsubsection Int (signed 32bit) properties
@itemize
@item @strong{@func{Int}      (@var{label}, @var{description}, @var{default}, @var{minimum}, @var{maximum}, @var{stepping}, @var{options})} @*
        An ordinary property of type @type{Int}. For GUIs and documentation generation, the
	translatable strings @var{label} and @var{description} are provided. The default,
	minimum and maximum values for the @type{Int} property are given by the respective arguments.
	The @var{stepping} argument can be used by GUIs to provide increment/decrement
	editing abilities. Possible values for @var{options} are discussed in the
	@uri{plugin-devel.html#options, property options section}.
@item @strong{@func{UInt}     (@var{label}, @var{description}, @var{default}, @var{options})} @*
        Similar to @func{Int()} where the minimum and maximum are fixed at 0 and 2147483647.
@item @strong{@func{Octave}   (@var{label}, @var{description}, @var{default}, @var{options})} @*
	An integer property ranging from -4 to +6 with variable default.
@item @strong{@func{FineTune} (@var{label}, @var{description}, @var{options})} @*
@item @strong{@func{Note} (@var{label}, @var{description}, @var{default}, @var{options})} @*
	Int property within 0 and 131 (sometimes also uses 132 to denote no/unspecified/unparsable note).
	For the @var{default} value, @bse provides a constant @const{KAMMER_NOTE} and a set of macros taking
	an octave argument:
@macro{NOTE_C(octave)}, @macro{NOTE_Cis(octave)}, @macro{NOTE_Des(octave)}, @macro{NOTE_D(octave)},
@macro{NOTE_Dis(octave)}, @macro{NOTE_Es(octave)}, @macro{NOTE_E(octave)}, @macro{NOTE_F(octave)},
@macro{NOTE_Fis(octave)}, @macro{NOTE_Ges(octave)}, @macro{NOTE_G(octave)}, @macro{NOTE_Gis(octave)},
@macro{NOTE_As(octave)}, @macro{NOTE_A(octave)}, @macro{NOTE_Ais(octave)}, @macro{NOTE_Bes(octave)},
@macro{NOTE_B(octave)}.
@done


@subsubsection Other properties
@itemize
@item @strong{@func{Num} (@var{label}, @var{description}, @var{default}, @var{minimum}, @var{maximum}, @var{stepping}, @var{options})} @*
	A signed 64bit numeric property similar to @type{Int} covering the integer
	range -9223372036854775808 til 9223372036854775807.
@item @strong{@func{String}   (@var{label}, @var{description}, @var{default}, @var{options})} @*
        @type{String} property, the @func{String()} constructor is used to provide a translatable
        label and translatable description and to define the default string value. For some strings
        it makes sense to provide additional options such as @option{searchpath}.
@item @strong{@func{Choice}   (@var{label}, @var{description}, @var{default}, @var{options})} @*
        Choice property, the @func{Choice()} constructor is used to provide a
        translatable label and translatable description and to define the default choice value.
@item @strong{@func{BBlock}   (@var{label}, @var{description}, @var{options})} @*
        Byte block property, the @func{BBlock()} constructor is used to provide a label and description.
@item @strong{@func{FBlock}   (@var{label}, @var{description}, @var{options})} @*
        Float value block property, the @func{FBlock()} constructor is used to provide a label and description.
@item @strong{@func{Record}   (@var{label}, @var{description}, @var{options})} @*
        Record type property, the @func{Record()} constructor is used to provide a translatable label
	and translatable description for properties that have the type of a previously defined record
	(see @uri{sfidl-manual.html#composite-types, sfidl Composite Types}).
@item @strong{@func{Sequence} (@var{label}, @var{description}, @var{options})} @*
        Sequence type property, the @func{Sequence()} constructor is used to provide a translatable label
	and translatable description for properties that have the type of a previously defined sequence
	(see @uri{sfidl-manual.html#composite-types, sfidl Composite Types}).
@item @strong{@func{Object}   (@var{label}, @var{description}, @var{options})} @*
        Object property, the @func{Object()} constructor is used to provide a translatable label
	and translatable description for properties that have the type of a previously defined object
	(see @uri{sfidl-manual.html#classes, sfidl Classes}).
@done


@anchor{options}
@subsection Property options

A special cpability of IDL properties is behavioural adjustment through an added option string.
Several options can be combined in such a string by concatenating them with ":", and options
can be enabled or disabled by postfixing them with "+" or "-".
The following lists describe the property options currently supported (defined) by @bse{}.

Property options from @type{GParamSpec}:
@itemize
@item @option{r} - the property is readable (same as @const{G_PARAM_READABLE})
@item @option{w} - the property is writable (same as @const{G_PARAM_WRITABLE})
@item @option{construct} - the property is writable (same as @const{G_PARAM_CONSTRUCT})
@item @option{construct-only} - the property is writable (same as @const{G_PARAM_CONSTRUCT_ONLY})
@item @option{lax-validation} - the property is writable (same as @const{G_PARAM_LAX_VALIDATION})
@done

BSE core options:
@itemize
@item @option{S}            - the property is serializable
@item @option{f}            - float indicator, reduce serialization precision to IEEE 754 Single Precision Floating Point
@item @option{skip-default} - do not serialize property if its set to its default value
@item @option{skip-undo}    - do not record property changes to undo/redo mechanism
@item @option{unprepared}   - the property is writable only for unprepared objects
@done

GUI Options:
@itemize 
@item @option{G}             - the property should be represented by GUIs
@item @option{ro}            - for GUI representation purposes, the property should be considered read-only (non-editable)
@item @option{trigger}       - a hint to display the property with a trigger button
@item @option{radio}         - a hint to display the property with a radio button
@item @option{dial}          - a hint to display the property with dial knob
@item @option{scale}         - a hint to display the property with a scale adjustment
@item @option{log-scale}     - a hint to display the property with a logarithmic scale adjustment
@item @option{db-value}      - a hint indicating a decibel valued property
	(as opposed to a property that is real valued but for which dB values should be displayed)
@item @option{db-volume}     - a hint indicating a dB volume scale for a dB or real valued property
@item @option{db-range}      - a hint indicating a dB scale with smooth curvature for a dB or real valued property
@item @option{searchpath}    - a hint indicating a property consisting of colon seperated directory list
@item @option{filename}      - a hint indicating a property consisting of a filename
@item @option{rgb}           - a hint indicating a property consisting of an RGB color value
@item @option{hex}           - a hint indicating a preference for base 16 in numeric editing
@item @option{item-sequence} - the property type is a sequence of item objects
@item @option{note-sequence} - the property type is a sequence of notes
@done

Predefined options sets:
@itemize
@item @const{READWRITE}        - property is readable and writable (@option{r:w})
@item @const{GUI}              - property is READWRITE and GUI representable (@option{r:w:G})
@item @const{GUI_RDONLY}       - property is GUI but non-editable (@option{r:w:G:ro})
@item @const{GUI_READABLE}     - property is readable and GUI representable but not writable (@option{r:G})
@item @const{STORAGE}          - property is READWRITE and serializable (@option{r:w:S})
@item @const{STANDARD}         - property is READWRITE, STORAGE and GUI (@option{r:w:S:G})
@item @const{STANDARD_RDONLY}  - property is READWRITE, STORAGE, GUI_RDONLY (@option{r:w:S:G:ro})
@done

Extra option sets (mostly for convenience and readability):
@itemize
@item @const{SKIP_DEFAULT}     - skip default value serialization (@option{skip-default})
@item @const{SKIP_UNDO}        - property changes are not undo/redo recorded (@option{skip-undo})
@done


@anchor{class-options}
@subsection Class options

The property option mechanism described in the last section has been adapted
for classes at some point. Currently, applications of this feature a very rare,
but expected to increase in the future. As such, the recognized option set for
classes also is very limited at the moment.

Predefined class options:
@itemize
@item @option{unstable}     - code is considered unstable and enabled only by @code{--devel}
@item @option{mix1}         - this class implements a mono channel mixer effect (also see @uri{plugin-devel.html#channels, channels})
@item @option{mix2}         - this class implements a stereo channel mixer effect
@item @option{mix5.1}       - this class implements a 5.1 channel mixer effect
@done


@subsection Adding a @file{PNG} icon

Every GUI representable object should have an icon eventually. Once an image file
exists in the desired format, it is easily integrated into a class definition:

@example
class NotchFilter : Effect {
  Info    icon      = "notch.png";	// use the image notch.png as class icon
};
@done

Images to be used as class icons should meet a few requirements:
@enumerate
@item @strong{Size}:   the class icon should be 64 pixels wide and 64 pixels heigh.
@item @strong{Colors}: the image should be provided in RGBA format with transparent background.
@item @strong{Format}: the image should be provided in a common image format, @file{PNG} is fully supported by @uri{sfidl.1.html, sfidl(1)}.
@done

@subsubsection Changing the icon


@section Writing the @file{C++} file

@subsection Module object methods

@subsection Engine module methods

@section An example notch filter

@section Integrating presets

@section Storing custom data

@section Additional Methods
