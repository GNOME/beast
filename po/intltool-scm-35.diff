diff -up po/Makefile.in.in.orig po/Makefile.in.in
--- po/Makefile.in.in.orig	2006-05-29 11:16:26.000000000 +0200
+++ po/Makefile.in.in	2006-05-30 10:28:28.000000000 +0200
@@ -58,7 +58,7 @@ PO_LINGUAS=$(shell if test -r $(srcdir)/
 
 POFILES=$(shell if test -n "$(PO_LINGUAS)"; then LINGUAS="$(PO_LINGUAS)"; else LINGUAS="$(ALL_LINGUAS)"; fi; for lang in $$LINGUAS; do printf "$$lang.po "; done)
 
-DISTFILES = ChangeLog Makefile.in.in POTFILES.in $(POFILES)
+DISTFILES = ChangeLog Makefile.in.in LINGUAS POTFILES.in $(POFILES)
 EXTRA_DISTFILES = POTFILES.skip Makevars LINGUAS
 
 POTFILES = \
@@ -204,6 +204,7 @@ update-po: Makefile
 	    rm -f $$tmpdir/$$lang.new.po; \
 	  fi; \
 	done
+distfile-list:
 
 Makefile POTFILES: stamp-it
 	@if test ! -f $@; then \
diff -up intltool-extract.in.orig intltool-extract.in
--- intltool-extract.in.orig	2006-05-29 11:16:26.000000000 +0200
+++ intltool-extract.in	2006-05-30 10:27:33.000000000 +0200
@@ -185,11 +185,13 @@ sub message {
 sub extract {
     &determine_type;
 
-    &convert;
-
     open OUT, ">$OUTFILE";
     binmode (OUT) if $^O eq 'MSWin32';
-    &msg_write;
+
+    my $need_msg_write;
+    $need_msg_write = convert();
+    &msg_write if $need_msg_write;
+
     close OUT;
 
     print "Wrote $OUTFILE\n" unless $QUIET_ARG;
@@ -205,6 +207,11 @@ sub convert {
 	$input = <IN>;
     }
 
+    if ($gettext_type eq "scm-funcs") {
+      &transform_scm_funcs;
+      return 0; # no need for msg_write()
+    }
+    
     &type_ini if $gettext_type eq "ini";
     &type_keys if $gettext_type eq "keys";
     &type_xml if $gettext_type eq "xml";
@@ -213,6 +220,7 @@ sub convert {
     &type_schemas  if $gettext_type eq "schemas";
     &type_rfc822deb  if $gettext_type eq "rfc822deb";
     &type_quoted if $gettext_type eq "quoted";
+    return 1; # need msg_write()
 }
 
 sub entity_decode_minimal
@@ -798,6 +806,56 @@ sub type_scheme {
     }
 }
 
+sub transform_scm_funcs {
+  my $scheme_subident = "abcdefghijklmnopqrstuvwxyz"."ABCDEFGHIJKLMNOPQRSTUVWXYZ".'!$%&*/:<=>?^_~'."0123456789".'+-.@';
+  my $state = 0;
+  my $letter = "";
+  for (my $i = 0; $i < length($input); $i++) {
+    my $char = substr($input,$i,1);
+    # here, we process the input char by char
+    # print $char;
+    # we use a simple state machine, states:
+    # 0 - normal state
+    # 1 - in string
+    # 2 - in backslash escape within string
+    # 3 - in comment
+    # 4 - in scheme expresssion after i18n letter
+    # 5 - maybe reading gettext identifier
+    # 6 - in scheme expresssion
+    if      ($state == 0) { # normal reading
+      $letter = "";
+      if    ($char eq "'")  { print OUT "&";	 	$state = 0; }
+      elsif ($char eq "#")  { print OUT "&";	 	$state = 0; }
+      elsif ($char eq '"')  { print OUT $char;	 	$state = 1; }
+      elsif ($char eq ";")  { print OUT '/*';	 	$state = 3; }
+      elsif ($char eq "(")  {                  	 	$state = 6; }
+      else                  { print OUT $char; }
+    } elsif ($state == 1) { # in string
+      if    ($char eq '"')  { print OUT $char;   	$state = 0; }
+      elsif ($char eq '\\') { print OUT $char;    	$state = 2; }
+      else                  { print OUT $char; }
+    } elsif ($state == 2) { # backslash escape
+      if    (1)             { print OUT $char;    	$state = 1; }
+    } elsif ($state == 3) { # comment
+      if    ($char eq "\n") { print OUT "*/\n";   	$state = 0; }
+      else                  { print OUT $char; }
+    } elsif ($state == 4) { # expression, consumed i18n letter, unprinted: '(?'
+      if    ($char eq "_")  {                  	 	$state = 5; }
+      else                  { print OUT "($letter";	$state = 0; $i -= 1; }
+    } elsif ($state == 5) { # maybe gettext, unprinted: '(_' or '(?_'
+      if    (index ($scheme_subident, $char) > -1)
+                            { print OUT "($letter"."_"; $state = 0; $i -= 1; }
+      else 		    { print OUT "$letter"."_(";	$state = 0; $i -= 1; }
+    } elsif ($state == 6) { # expression, unprinted: '('
+      if    ($char eq "_")  {                  	 	$state = 5; }
+      elsif ($char eq "N")  { $letter = "N";   	 	$state = 4; }
+      elsif ($char eq "Q")  { $letter = "Q";   	 	$state = 4; }
+      elsif ($char eq "U")  { $letter = "U";   	 	$state = 4; }
+      else                  { print OUT "(";      	$state = 0; $i -= 1; }
+    }
+  }
+}
+
 sub msg_write {
     my @msgids;
     if (%count)
